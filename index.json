[{"content":" 本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\n开机动画文件路径 系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\n/apex/com.android.bootanimation/etc/bootanimation.zip (since Android 10) /product/media/bootanimation.zip (since Android 9) /oem/media/bootanimation.zip /system/media/bootanimation-encrypted.zip (if getprop(\u0026#34;vold.decrypt\u0026#34;) = \u0026#39;1\u0026#39;) /system/media/bootanimation.zip 注释1：搜索 /product 分区的特性在 Android 9 被添加，搜索/apex 分区的特性在 Android 10 才被添加，按照历史惯性而言，厂商默认的开机动画一般保存在/system分区。\n注释2：vold.decrypt属性表明此 Android 系统开启了全盘加密。全盘加密特性从 Android 10 开始已被废弃，只有在启用此特性的机器上才需要特别关注bootanimation-encrypted.zip文件。\n文件结构 bootanimation.zip一般包含以下文件：\ndesc.txt - 描述如何执行动画的文本文档 part0 \\ part1 \\ 文件夹，包含一段动画所有的帧，这些帧以PNG文件保存 ... / partN / bootanimation.zip允许定义多个不同的动画片段，并把它们串联在一起组成完整的开机动画，这些动画片段存储在不同的partN文件夹里，其中 N 指的是序号的数字。\npartN文件夹里除了包含一帧帧 PNG 图片，还可以包含一些其他资源或配置文件。\ndesc.txt 第一行定义动画的通用参数\nWIDTH HEIGHT FPS [PROGRESS] WIDTH: 动画宽度（像素） HEIGHT: 动画高度（像素） FPS: 每秒帧数，例如60 PROGRESS：（可选，since Android 12），是否显示最后一个动画片段的进度百分比 百分比将水平居中，y 坐标将被设置为动画高度的1/3。 第二行以及以后的若干行定义一个动画片段：\nTYPE COUNT PAUSE PATH [#RGBHEX [CLOCK1 [CLOCK2]]] TYPE: 单个字符，或$SYSTEM，指示动画片段的类型： p: 播放这段动画，但会被开机完成事件打断 c: 完整播放这段动画，即使开机完成, 动画也不会被打断 $SYSTEM: 加载 /system/media/bootanimation.zip 并播放它。 COUNT: 最大播放多少次动画，如果设置为 0，则动画无限循环直到启动完成 PAUSE: 该部分结束后延迟多少帧再播放下一个动画片段 PATH: 动画资源目录（例如part0） RGBHEX: （可选）背景颜色，格式为#RRGGBB CLOCK1、CLOCK2：（可选）绘制当前时间的坐标（对于手表）： 如果仅提供CLOCK1，则它会被解析为时钟的 y 坐标，时钟的 x 坐标默认为c （since Android 9）如果同时提供了CLOCK1和CLOCK2，则第一个作为 x 坐标，第二个作为 y 坐标 值可以是正整数、负整数或c c：将文本居中 正整数n，：x 坐标，从屏幕左边缘开始算起的像素，y 坐标，从屏幕下边缘开始算起的像素 -n：x 坐标，从屏幕右边缘开始算起的像素，y 坐标，从屏幕上边缘开始算起的像素 例子： -24或者c -24，将文本定位在距屏幕顶部 24 像素处，水平居中 16 c，将文本定位在距屏幕左侧 16 像素处，垂直居中 -32 32，将文本定位在屏幕右侧 32 像素、底边缘上方 32 像素处 注意，同时指定时钟的 x、y 坐标是从 Android 9.0 开始支持的特性，Android 9.0 以前只支持指定 y 坐标\nclock_font.png(since Android 9) 可以使用该文件指定绘制时间使用的字体。字体文件格式要求如下：\n该文件指定 ASCII 字符 32-127 (0x20-0x7F) 的字形，包括常规粗细和粗体粗细。 图像被划分为字符网格 有16列和6行 每行分为两半部分：上半部分为常规粗细字形，下半部分为粗体字形。 对于 NxM 大小的图像，每个字符字形的宽度为 N/16 像素，高度为 M/(12*2) 像素 加载和播放动画帧 每部分的动画都直接从 zip 文件中扫描并加载。在partN目录下，每个文件（除了trim.txt和audio.wav，请参阅下一节）都应该是一个 PNG 文件，表示该动画中的一帧（以指定的分辨率）。因此，必须按顺序命名动画帧（比如part000.png、part001.png）并按该顺序添加到 zip 文件中。\ntrim.txt 可以对动画帧进行缩放，只需要在partN目录下提供trim.txt 文件即可。这个文件按顺序列出其目录中每个帧的缩放输出，因此可以将动画帧放在合适的位置上。输出应采用以下形式：WxH+X+Y，其中W和H表示重新放大或缩小后的动画帧大小。例如：\n713x165+388+914 708x152+388+912 707x139+388+911 649x92+388+910 如果不提供该文件，则假定每个帧的大小与desc.txt中指定的宽高参数相同。\naudio.wav 每个动画片段可以选择在开始时播放wav。要启用此功能，请在partN目录下提供audio.wav文件。\n退出开机动画 系统完成启动后将结束开机动画（仍会播放任何没播完甚至还没开始播放的类型为c的开机动画），这是通过将系统属性service.bootanim.exit设置为非零字符串来完成的。\n提示 PNG压缩 可以使用zopflipng或pngcrush来压缩 PNG 图像。例如：\nfor fn in *.png ; do zopflipng -m ${fn}s ${fn}s.new \u0026amp;\u0026amp; mv -f ${fn}s.new ${fn} # or: pngcrush -q .... done 如果允许将动画减小到256种颜色，压缩效果会更好，酌情使用：\npngquant --force --ext .png *.png # alternatively: mogrify -colors 256 anim-tmp/*/*.png 如何创建 ZIP cd \u0026lt;path-to-pieces\u0026gt; zip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part* 请注意，ZIP 文件的压缩等级为0，实际上并未压缩！（使用其他压缩等级会导致读取文件失败） 因为 PNG 文件已经尽可能压缩，文件之间不太可能有任何冗余。\n开机动画与动态颜色(since Android 12L) 从 Android 12L 开始，Google 团队将 Android 12 引入的Dynamic color特性也应用到了开机动画上。在此模式下，开机动画不再直接渲染 PNG 图像，而是将 PNG 图像的 R、G、B、A 通道视为动态颜色的 mask（掩码），根据动画的进度，在开始颜色和结束颜色之间进行插值。\n要启用动态颜色特性，需要在 desc.txt 的第二行添加以下文本：\ndynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4 PATH： 要应用动态颜色过渡的部分的文件路径。该片段之前的任何部分都将以起始颜色渲染。之后的任何部分都将以最终颜色渲染。 RGBHEX1： 第一个起始颜色（masked by the R channel），指定为#RRGGBB。 RGBHEX2： 第二个起始颜色（masked by the G channel），指定为#RRGGBB。 RGBHEX3： 第三个起始颜色（masked by the B channel），指定为#RRGGBB。 RGBHEX4： 第四个起始颜色（masked by the A channel），指定为#RRGGBB。 将从以下系统属性中读取结束颜色：\npersist.bootanim.color1 persist.bootanim.color2 persist.bootanim.color3 persist.bootanim.color4 如果上面的某个系统属性为空，相应的结束颜色将默认为开始颜色，这样不会产生颜色转换。\n准备您的PNG图像，使 R、G、B、A 通道分别指示要绘制color1、color2、color3和color4的区域。\n动态颜色与开机动画的关系 简单来说，动态颜色是根据用户的相关设置（比如壁纸）等动态生成主题颜色调色板，并应用到系统上的过程。主题色变更后，系统将其更新在系统属性persist.bootanim.color1到persist.bootanim.color4上，也就是上文所说的结束颜色，开机动画通过读取系统属性并应用到动画上以支持动态颜色。\n但经过上文的分析，我们也都清楚开机动画实际由一张张 PNG 图片组成的，图片上的颜色肯定是固定的，那么如何做到动态着色呢？\n其实，图像本质上是保存“坐标”到“颜色”的映射的二维数组，想要支持动态颜色，我们需要给出“图像上的颜色”到“系统的动态颜色”的映射，那么解决方式就很简单了：\n首先，我们从动画中提炼几种主要出现的固定颜色并把它们映射到动态颜色上，对比上面的描述，这一步相当于在desc.txt中填写dynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4，每一个被填上去的固定颜色会被映射到相应的系统属性。\n接下来，原来的动画帧中不应再保存固定颜色，而是保存这些颜色的“索引”，比如说我们简单用1、2、3、4来索引四种固定颜色，0表示没有任何颜色，那么，一个3x3的图像看起来可能像这样：\n[0, 0, 0], [0, 1, 2], [0, 4, 3] 这种索引方式没有任何问题，只是稍显笨拙。除了简单的索引值，我们还可以考虑混合四种固定颜色的情况，即用四维向量来表示一个位置上的颜色，向量的分量表示混合了多少对应的固定颜色，这类似于我们用 RGB 来表示颜色，只不过现在三原色变成了“四原色”（姑且不考虑这四种颜色能不能组成正交基）。我们如何保存向量的分量值呢？原来的 PNG 图像在这时就派上了用场，PNG 图像有 ARGB 四个颜色通道，正好对应向量的四个分量！\n如果有助于你理解的话，你还可以认为我们将图像的标准正交基从纯色变换为其他颜色\nBootAnimation.cpp 中的 glsl 代码如下：\nprecision mediump float; const float cWhiteMaskThreshold = 0.05; uniform sampler2D uTexture; uniform float uFade; uniform float uColorProgress; uniform vec3 uStartColor0; uniform vec3 uStartColor1; uniform vec3 uStartColor2; uniform vec3 uStartColor3; uniform vec3 uEndColor0; uniform vec3 uEndColor1; uniform vec3 uEndColor2; uniform vec3 uEndColor3; varying highp vec2 vUv; void main() { vec4 mask = texture2D(uTexture, vUv); float r = mask.r; float g = mask.g; float b = mask.b; float a = mask.a; // If all channels have values, render pixel as a shade of white. float useWhiteMask = step(cWhiteMaskThreshold, r) * step(cWhiteMaskThreshold, g) * step(cWhiteMaskThreshold, b) * step(cWhiteMaskThreshold, a); // 图像的rgba现在变为了动态颜色的系数, 这意味着它们共同指导了某个像素应当混合哪几类基色，并且每种基色混合到什么程度 vec3 color = r * mix(uStartColor0, uEndColor0, uColorProgress) + g * mix(uStartColor1, uEndColor1, uColorProgress) + b * mix(uStartColor2, uEndColor2, uColorProgress) + a * mix(uStartColor3, uEndColor3, uColorProgress); // 如果图像的rgba都有值，那么将会求rgba的平均值, 并将这个平均值作为颜色的三个分量，也就是说颜色变成灰色或白色 color = mix(color, vec3((r + g + b + a) * 0.25), useWhiteMask); gl_FragColor = vec4(color.x, color.y, color.z, (1.0 - uFade)); } 调试技巧 如果希望在运行中的系统调试开机动画，请顺序执行以下命令：\nadb root adb remount // 覆盖系统中原本的开机动画，push命令的路径应根据实际情况修改 adb push .\\bootanimation.zip /system/media/bootanimation.zip // 这个属性标记了开机动画是否应当退出, 重置这个标志以保证开机动画会被执行(即使类型为p) adb shell setprop service.bootanim.exit 0 adb shell setprop ctl.start bootanim 如果开机动画被配置为无限循环，再次执行以下命令（重新置位）才能终止开机动画：\nadb shell setprop service.bootanim.exit 1 ","permalink":"https://usagisang.github.io/posts/android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"开机动画文件路径\"\u003e开机动画文件路径\u003c/h2\u003e\n\u003cp\u003e系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\u003c/p\u003e","title":"Android开机动画修改指南"},{"content":"不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是RSA是其中最容易让人理解的。下文将尝试对RSA实现的具体流程进行解析。\n寻找合适的加密、解密函数 我并不知道RSA最初的诞生经过了怎样的启发与灵光一闪，但仍有办法切入RSA的设计思路，现在，我们从它的实际效果：公钥加密，私钥解密来入手，尝试一步步分析它，了解它。\n我们首先面临的问题是，如果想要达到加解密的钥匙分开的效果，应当怎么做呢？\n先尝试使用数学语言抽象化描述一下这个问题：\n设加密函数为$f_1(m,e)$，m为明文，e为加密密钥，解密函数为$f_2(x,d)$，x为密文，d为解密密钥，那么，我们需要寻找函数$f_1$和$f_2$，使得：$m=f_2(f_1(m, e),d)$成立，经过函数$f_1$和$f_2$两次变换之后，我们需要能够把明文给还原回来。\n为了解决上面的问题，我们需要对两个数学知识有一定的了解，第一个是欧拉定理，第二个则是模算术。\n欧拉定理 $$ 若a,m均为正整数,且gcd(a,m)=1,则a^{\\varphi(m)}\\equiv 1 (\\mod m) $$ $gcd(a,m)$表示求数a和m的最大公因数，如果最大公因数为1，这两个数互质。\n其中$\\varphi(m)$是一个重要的数论函数：欧拉函数。$\\varphi(m)$表示小于等于m的正整数中与m互质的数的数目。显然，若m为素数，则$\\varphi(m)=m-1$。\n基本的模算术 如果A和B满足$A \\mod n=B\\mod n$，我们称之为A与B有同余关系，同余关系常常又表示成：$A\\equiv B (\\mod n)$。同余关系是一种等价关系。\n模的含义可以换算为普通乘式： $$ A\\mod B=C \\rightarrow A=kB+C $$ 基本的模加法和模乘法、模幂运算规则如下： $$ \\displaylines{ (A + B) \\mod C = (A \\mod C + B \\mod C) \\mod C \\\\ (A * B) \\mod C = ((A \\mod C) * (B \\mod C)) \\mod C \\\\ (A^B)\\mod C = (A\\mod C)^B \\mod C \\\\ } $$\n了解了模幂的规则，其实我们很快就能发现函数$f(a,x)=a^x\\mod m$很有趣，因为存在$f(f(a,e),d)=f(a,ed)$，即$(a^e \\mod m)^d \\mod m = a^{ed} \\mod m$成立，而$a^{ed} \\mod m$与$a^{\\varphi(m)}\\equiv 1 (\\mod m)$之间的相似度又不禁令我们遐想联翩。实际上，欧拉定理再变通一下，我们就能得到$a^{\\varphi(m)+1}\\mod m=a$，其中$a \u003c m$。那么，要是$ed=\\varphi(m)+1$的话，不就有$a^{ed} \\mod m=a^{\\varphi(m)+1}\\mod m=a$了吗？！那么，我们现在这样来描述我们的加解密函数$f_1$和$f_2$，令$f_1=f_2=a^x\\mod m$，其中a为明文，选择一个$m$，计算$\\varphi(m)$，公钥和私钥的策略是，然后选择一个$e$并根据$ed=\\varphi(m)+1$计算$d$。\n经过上面的简单思考，我们来解决一些随之而来的问题。\n首先，我们为了得到$a^{\\varphi(m)+1}\\mod m=a$，实际上弱化了欧拉定理，要求底数$a \u003c m$。不过这并不是什么大问题，底数a代表的明文如果实在太长，我们把它分割一下，让它小于m就行了。\n其次，欧拉定理还要求底数a和模m互质（$gcd(a,m)=1$），这是一个比较严苛的要求。幸运的是，即使明文a与m不互质，我们也可以证明我们的加密、解密函数仍然有效，稍后将给出证明。\n另外，在实现上仍有诸多疑问：一个数的幂的结果增长得特别快，计算$a^{ed}$是否很容易超出编程语言中整型变量的范围呢？如何根据$n$确定$\\varphi(n)$？\n快速模幂 我们先来解决计算$a^{ed}\\mod n$的问题。\n例如，要求计算$2^{256}\\mod 7$。显然，先计算出$2^{256}$不是什么明智的选择。根据模算术的基本规则，我们可以得到： $$ 2^{256}\\mod 7=(2^{128}\\mod 7*2^{128}\\mod7)\\mod7 $$ 如何求$2^{128}\\mod 7$呢？答案是去求解$2^{64}\\mod 7$，这样循环递归下去，我们可以凭借$2\\mod 7$的结果计算$2^{256}\\mod 7$！这是基于分治思想得出的算法。\n不过，如果幂不能被2整除呢？例如求$3^{117}\\mod 7$。这时，关键在于如何对整数117按照2的若干次幂进行划分，其实117的二进制表示本身就是一种天然划分。把117表示成二进制：$117=(1110101)_2$，$3^{117}=3^{2^0+2^{2}+2^{4}+2^{5}+2^{6}}=3^1*3^4*3^{16}*3^{32}*3^{64}$\n我们可以使用动态规划的思想，自底向上进行迭代来求解这个问题。\n分析递推式，有$2^k\\mod n=(2^{k-1}\\mod n)^2\\mod n$，事实上动态规划表内第k项只和第k-1项有关，我们可以省略一个完整的动态规划表，只保留k-1项。\npublic static int fastModularExponentiation(int base, int power, int p) { // 缓存k-1项 int i = base % p; int result = 1; while (power \u0026gt; 0) { if ((power \u0026amp; 1) == 1) { result = (result * i) % p; } i = (i * i) % p; power = power \u0026gt;\u0026gt; 1; } return result; } 如何产生n与如何计算$\\varphi(n)$ 因为我们选定了$f(m,e)=m^e\\mod n$来进行加密运算，那么公钥e和模n都需要公开，其他人才可以进行加密。$n$被公开则触及一个核心的问题：既然$n$被公开，$\\varphi(n)$不是很容易被计算出来吗？又有$ed=\\varphi(n)+1$，那么密钥$d$不是很容易确定吗？这样还存在保密性吗？\n首先，对于一个合数而言，欧拉函数$\\varphi(n)$的值其实不那么容易被计算出来，因为没有有效的算法来计算甚至估算这个函数的值，我们只能暴力地从1到$n-1$，一个个去尝试它是否与n互质。问题随之而来，如果公开的模n复杂到别人无法暴力破解$\\varphi(n)$，那么我们又凭什么能够快速算出$\\varphi(n)$呢？算法又需要这个值来生成公钥和私钥。\n下面的这个定理完美解决了上述问题 $$ 若p和q都是素数，n=pq，那么\\varphi(n)=\\varphi(p)\\varphi(q) $$ 以上定理不作证明，我们使用这个定理，轻易就能得出$\\varphi(n)=(p-1)(q-1)$，也就是说，只要找到n的两个素数因子，我们就能确定$\\varphi(n)$，以这种思路来计算$\\varphi(n)$的可行性基本上是……0。是的，当n相当大的时候，找出两个素数因子简直难如登天。我们不是采用这种方法来计算$\\varphi(n)$，而是以这种思路来生成$n$，从而不费吹灰之力得到$\\varphi(n)$：先选择两个大素数p和q，然后计算n=pq，$\\varphi(n)$自然等于$(p-1)(q-1)$，而公开的公钥对{e，n}中，别人只拿到了n，想计算出$\\varphi(n)、p、q$反而相当困难。\n公钥e和私钥d的生成 既然我们已经调整了n的生成过程，其实公钥e和私钥d的生成过程我们也需要调整了。因为要求$ed=\\varphi(n)+1$不一定能得到满足，我们不能保证$\\varphi(n)+1$一定是一个合数，为此不停生成n显得有点本末倒置，我们希望能够得到一个更简洁的公钥私钥生成过程。\n$ed=\\varphi(n)+1$不一定成立？没关系，我们可以加入一个系数k，构造$ed=k*\\varphi(n)+1$，k为整数，当k=1时不成立也不要紧，只要有一个k能使得上述式子成立就行了。加上k之后，$ed$的含义并没有改变，因为$a^{\\varphi(n)}\\equiv 1 (\\mod n)$成立意味着$a^{k\\varphi(n)+1}\\equiv a (\\mod n)$也成立。\n先不讨论是否真的存在一个这样的k，我们先来化简一下这个式子。还记得模与普通算式的转换吗？ $$ ed=k*\\varphi(n)+1\\rightarrow ed\\equiv 1(\\mod \\varphi(n)) $$ 然后，上述式子还可以写为 $$ d= e^{-1}\\mod \\varphi(n) $$ d称之为e的模逆元，不过e的模逆元的意思可不是e的倒数求模，而是求一个数d能使得e与d的乘积与1同余。\n经过修改，我们暂时把公钥e和私钥d的生成过程描述如下： $$ 选择一个公钥e，计算私钥d= e^{-1}\\mod \\varphi(n)。 $$ 现在我们再来思考这个问题：是否存在一个整数k，使得$ed=k*\\varphi(n)+1$成立呢？如果不成立，私钥d就不存在了。需要什么前提条件使得k存在吗？\n解决这个问题需要引入线性同余方程的概念。 $$ 在数论中，形如ax\\equiv b(\\mod n)的形式的方程称之为线性同余方程 $$ 此方程有解当且仅当$b$能够被$a$与$n$的最大公因数整除。该性质的详细证明忽略。由该性质得到下面的引理： $$ 设a和b不全为0，则存在整数x，y，使得gcd (a,b)=ax+by $$ 我们拿出方程式$ed\\equiv 1(\\mod \\varphi(n))$对比上面的同余方程一般式，就能发现，只要e和$\\varphi(n)$的最大公因数为1(它们互质)，那么方程的解就存在，也就是私钥d存在。\n既然证明了私钥d是存在的，剩下的问题则是如何计算它。计算私钥d的核心思想是扩展欧几里得算法。\n提到欧几里得算法（GCD），相比各位不会陌生，这是一个求数A和B的最大公因数的高效算法，我们有 $$ gcd(a,b)=gcd(b, a\\mod b) $$ 该算法正确性的证明不作讨论，我们仅关注怎么使用它来解决同余方程，计算出我们想要的私钥d。\n下面是扩展欧几里得算法的思路： $$ \\begin{aligned} gcd(a,n)\u0026=ax_1+ny_1 \\\\ gcd(n, a \\% n) \u0026= nx_2+(a\\% n)y_2\\\\ \u0026=nx_2+(a-a/n*n)*y_2 \\\\ \u0026= nx_2+ay_2-a/n*n*y_2 \\\\ \u0026=ay_2+n(x_2-a/n*y_2) \\\\ \\end{aligned} $$ 因为$gcd(a,n)=gcd(n, a % n)$，所以$x_1=y_2,y_1=x_2-a/n*y_2$，我们得到了计算a与n的最大公因数的过程中x和y的递推公式，据此可以写出算法的简单实现代码。\npublic static int x = 0; public static int y = 0; /** * 计算ax+ny=1的特解 */ public static int gcd(int a, int n) { if (n == 0) { x = 1; y = 0; return a; } else if (a == 0) { x = 0; y = 1; return n; } else { int c = gcd(n, a % n); int tmp = x; x = y; y = tmp - a / n * y; return c; } } 上面的静态变量x就是我们想要的私钥d。现在，生成私钥d已经不是难题了。\nRSA算法全过程 我们已经差不多把RSA算法的全过程都解释了一遍，现在来浏览一下真正的RSA算法全过程吧。\n密钥生成 选择大素数p与q，计算$n=pq$，$\\varphi(n)=(p-1)(q-1)$，然后丢弃p和q，不保留。 在$1 \u003c e \u003c \\varphi(n)$的范围内选择整数公钥e，使得$gcd(e,\\varphi(n))=1$（若$e$和$\\varphi(n)$不互质，则不存在私钥$d$，这点上面已经证明过了）。 计算私钥d，$d=e^{-1}\\mod \\varphi(n)$。 加密过程 发送方获得公钥对{e,n} 把明文$m$分解为小于n的若干块 计算密文$C=m^e\\mod n$ 解密过程 接收方提前内置密钥对{d,n} 对密文解密$m=C^d\\mod n$ 尾声：RSA算法正确性证明 回到我们最开始先忽略的那一个问题，既然欧拉定理要求底数a与模n互质，当明文a与模n不互质的时候，还能够完成加密并解密的任务吗？先给出结论，结论是只要a不是模n的倍数，RSA算法就是正确的。既然我们要求了$a \u003c n$，那么a是n的倍数的可能性不复存在。\n以下是证明： $$ 设n=pq，a是某一个整数、gcd(a,n)\\neq 1 且a不能被n整除，试证明a\\equiv a^{k\\varphi(n)+1}(\\mod n) $$\n$$ \\displaylines{ 若a与n不互质，必有p|a(a能被p整除)或者q|a。设p|a成立，必有gcd(q,a)=1，否则n|a，不符合题设条件。\\\\同理设q|a成立也是一样的情况，不失一般性，设p|a成立。 由欧拉定理和\\varphi(n)=(p-1)(q-1)得到：\\\\ a^{\\varphi(n)}\\equiv 1(\\mod q) \\\\ a^{k\\varphi(n)}\\equiv 1(\\mod q) \\\\ 令m为整数,有\\\\ a^{k\\varphi(n)}=mq+1\\\\ a^{k\\varphi(n) + 1}=maq+a\\\\ 将a分解为a=xp \\\\ a^{k\\varphi(n) + 1}=mxpq+a=mxn+a\\\\ 则a^{k\\varphi(n) + 1}\\equiv a(\\mod n)成立 } $$\n","permalink":"https://usagisang.github.io/posts/rsa/","summary":"\u003cp\u003e不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是RSA是其中最容易让人理解的。下文将尝试对RSA实现的具体流程进行解析。\u003c/p\u003e","title":"RSA"}]