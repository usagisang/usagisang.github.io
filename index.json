[{"content":"link CS-Note 18.2 删除链表中重复的结点\nLeetcode 删除排序链表中的重复元素\nLeetcode 删除排序链表中的重复元素 II\n题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。\ninput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 output: 1-\u0026gt;2-\u0026gt;5 使用 cpp 实现无需手动管理内存。\n解题思路 我们给出了 leetcode 中两道类似的题目，“删除排序链表中的重复元素 II” 正是本节题目描述中所述的问题，而前一个是这个问题的简化版，即重复时仅保留其中一个结点。既然保留重复结点的做法是更简单的，那么我们不妨先解决简单的问题，最后利用一个标记来删除最后这个被保留下来的结点即可。\n我们定义的链表结点的结构如下：\nstruct Node { int val; Node *next = nullptr; }; 首先，我们给出\u0026quot;删除排序链表中的重复元素\u0026quot;的实现代码，这个问题比较简单，不另外建立页面：\nvoid delete_repeat_node(Node **head) { Node *p = *head; while (p) { while (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val) { p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; } p = p-\u0026gt;next; } } 非常简单对不对？在内层的 while 循环，我们比较了当前选中的结点和下一个结点的值，如果相等，则我们修改p-\u0026gt;next以表明我们从链表中删除了下一个结点，直到遇到一个新的不同的值。外层的 while 循环则保证将指针移动到这个不同的值所代表的结点。\n相信你已经察觉出如何扩展上述代码来解决一个更复杂的问题了。没错，在第 6 行到第 7 行之间，p 很有可能指向了那个还没有被删除的，现在已经成了“孤家寡人”的重复元素。因此，我们在这其中插入检查并删除的代码，就可以解决本问题。伪代码如下：\nvoid delete_repeat_node(Node **head) { Node *p = *head; while (p) { while (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val) { p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; } // 如果p是重复元素, 我们应当从链表中删除p if (p_is_repeat){ delele p; } p = p-\u0026gt;next; } } 沿着这个思路来解决问题需要有两个要点。\n第一，我们需要判断 p 是否指向重复元素，可以简单设置一个标志位，并在进入内层 while 循环后置为 true ，说明 p 确实指向重复元素。第二，要想删除 p，我们就必须找到它的前向结点，好在，我们外层 while 循环算得上是对链表的线性遍历，因此，我们在遍历时可以多保存一个变量，表示当前结点的前向结点prev。\n代码实现 第一种实现如下：\nvoid delete_repeat_node(Node **head) { Node *prev = nullptr; Node *p = *head; while (p) { bool delete_self = false; while (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val) { delete_self = true; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; } if (delete_self) { if (prev) { prev-\u0026gt;next = p-\u0026gt;next; } else { // header *head = p-\u0026gt;next; } } else { prev = p; } p = p-\u0026gt;next; } } 注意到，我们在第 2 行设置了prev以保存前向结点，在第 5 行设置了delete_self标志位以记录p是否需要删除。第 10 行到第 19 行对prev的处理可能会有些难以理解，我们解析一下。\n首先，如果p需要被删除，而且prev不为空，说明p不是头结点。原本prev-\u0026gt;next指向p，在第 12 行，我们更新prev-\u0026gt;next为p-\u0026gt;next，这样p就从链表中被删除了。此时，prev需要被更新吗？不需要，因为此时prev依然将是下一轮迭代的指针的前向节点！\n若prev为空，那么p是头结点，在第 14 行我们必须修改头指针才能完成删除操作。\n若p并不需要被删除，那么，结合第 20 行，p将继续向下移动，因此，我们必须修改prev指针，否则prev性质就被破坏了。\n我们可以进一步优化上述代码。事实上，标志位只需要设置和判断一次，因此，我们可以用一次看似冗余的前置 if 判断来消除对标志位的使用，如下所示：\nvoid delete_repeat_node_re(Node **head) { Node *prev = nullptr; Node *p = *head; while (p) { if (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val) { while (p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;val == p-\u0026gt;val) { p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; } if (prev) { prev-\u0026gt;next = p-\u0026gt;next; } else { // header *head = p-\u0026gt;next; } } else { prev = p; } p = p-\u0026gt;next; } } 我们抢先判断p是否有可能被删除，如果不可能，则我们直接移动prev和p的指针即可；否则我们进入一个内层 while 循环，直到找到第一个拥有不同的值的结点。\n这个问题还有另一种解法，采用了递归形式来实现，可能没有这么直观。\nNode *delete_repeat_node_recursion(Node *head) { if (!head || !head-\u0026gt;next) { return head; } Node *p = head-\u0026gt;next; while (p \u0026amp;\u0026amp; head-\u0026gt;val == p-\u0026gt;val) { p = p-\u0026gt;next; } if (head-\u0026gt;next != p) { return delete_repeat_node_recursion(p); } head-\u0026gt;next = delete_repeat_node_recursion(p); return head; } 首先，在第 2 行至第 4 行，我们定下递归结束的基础条件，在传入的结点为空或无后继结点的情况下，我们直接返回头指针即可。\n接下来，在第 5 行到第 8 行，我们进行一次遍历，结束条件是指针p的值和头指针的值不一致。这里存在两种可能，第一种可能是 while 循环的第一次条件检查就失败了，即head-\u0026gt;next的值和head的值不一致，这种情况下不会命中第 9 行的 if 判断；第二种可能是 while 循环的第一次条件检查成功，因此指针p继续向后移动直到为 null 或第一个与head的值不相等的结点，此时，命中第 9 行的 if 语句。\n第 9 行到第 11 行的 if 语句本质上是这个意思：头节点和后续若干结点的值重复，我们直接抛弃这些结点，然后以p为头节点的链表去重的结果为整个问题的结果（以一个新的子问题的解答作为整个问题的解答）。\n如果未命中 if 语句，则头节点是整个问题解答的一部分，我们只要再获得以head-\u0026gt;next（提醒一下，此时head-\u0026gt;next == p是成立的哦）为头节点的链表去重的结果。由于这个子链表的头节点依然可能发生变更，因此我们需要重新为head-\u0026gt;next赋值。\n递归解法的思路在于，找到第一个不一致的结点然后直接抛弃前面的所有结点。如果我们沿着这种思路来组织代码，迭代实现会有什么不同吗？以下是实现：\nvoid delete_repeat_node_refactor(Node **head) { Node *prev = nullptr; Node *p = *head; while (p) { Node *next = p-\u0026gt;next; while (next \u0026amp;\u0026amp; next-\u0026gt;val == p-\u0026gt;val) { next = next-\u0026gt;next; } if (next != p-\u0026gt;next) { if (prev) { prev-\u0026gt;next = next; } else { // header *head = next; } p = next; } else { prev = p; p = p-\u0026gt;next; } } } 在第 5 行，我们使用next结点来迭代并保存我们遇到的第一个持有不同的值的结点。在第 11 行，我们用赋值prev-\u0026gt;next = next来表示直接抛弃next前面的所有结点。但，两个 if 分支的指针p的移动策略将会发生变化，在直接抛弃结点的分支中，由于p-\u0026gt;next已经无效了，我们必须让p移动到next的位置。\nby the way，如果你把next看作是p-\u0026gt;next的别名，那么上述实现代码其实和第一种思路几乎一致。而且少一个next指针，p的移动策略还能统一为p = p-\u0026gt;next，而不是只能分类讨论。\n","permalink":"https://usagisang.github.io/posts/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9/","summary":"\u003ch2 id=\"link\"\u003elink\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/18.2%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.md\"\u003eCS-Note 18.2 删除链表中重复的结点\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-list\"\u003eLeetcode 删除排序链表中的重复元素\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii\"\u003eLeetcode 删除排序链表中的重复元素 II\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"题目描述\"\u003e题目描述\u003c/h2\u003e\n\u003cp\u003e在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。\u003c/p\u003e","title":"删除排序链表中重复的结点"},{"content":"link CS-Note 41.1 数据流中的中位数\nLeetcode 295. 数据流的中位数\n题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n数据流将通过回调一个insert()方法来提供，C 语法的函数签名如下，其他语言类似：\nvoid insert(int); 在插入数据的过程中，实现还将调用若干次获得当前中位数的函数，函数签名如下：\nint get_median(void); 解题思路 “中位数”这个概念本身就与顺序直接相关。在一个有序数组中，我们想要获得中位数是很容易的。但这道题的挑战之处在于，其组成元素是依次插入的。因此，我们至少需要维护一个相对有序的集合，才能够获得中位数。\n面对“在有序数组中插入新元素”这个场景，第一时间可以想到二分查找。扩展版本的二分查找将为我们返回插入点，比起线性遍历要更加高效。但是，以这个思路解决问题的方式的瓶颈不在于二分查找，而在于“插入”。尽管二分查找很快，但在一个顺序数组中插入元素却很慢，最坏的情况下我们可能需要付出线性的代价。我们用来改善插入性能的链表也很难运用在这个问题上：想要高效运行二分查找，集合必须支持随机访问。总之，此方式可行，但肯定不是最高效的。\n接下来我们介绍一种非常巧妙的思路，想要想到这种思路需要一些积累和灵感。\n在上面一种解决思路中，困扰着我们，让我们的解答的效率不够高的痛点是什么？是我们无法高效完成一个一个插入元素并维持数组有序性这件事。有没有既能维持相对有序又能快速处理插入操作的抽象数据结构呢？还真有，那就是堆。当然，我们不能直接使用堆解决这个问题，因为此问题要求对中位数进行“随机访问”，堆的特性导致我们很难在插入的中途访问中位数。\n另外的一点灵感来自中位数的定义上。Wikipedia 上对中位数的定义如下：\nThe median of a set of numbers is the value separating the higher half from the lower half.\n一组数据的中位数是 higher half 和 lower half 之间的分隔值。\n中位数分隔了数组的两个半边，按照这种思路，我们把一个有序数组“掰成两半”，如下图所示：\n箭头方向是数组元素的大小方向。将数组“折半”后，中位数一定会位于两个“半截数组”的开头。\n我们换了一种方式来看待中位数与数组的关系，那么这和堆有什么关联吗？有。我们现在不妨假设数组含有偶数个元素，则，中位数一定是两个数字的平均，而且这两个数字一定来源于两个半截数组的最左侧。换句话说，中位数由下半截数组的最小值和上半截数组的最大值组成。看到最小值和最大值，我们已经有些眉目了，因为堆就是一个适合用来维护当前最大/最小值的数据结构，而且这个值恰巧也位于整个数组的开头！换句话说，如果我们将整个数组拆成两截，这两截各自维护一个最小堆和最大堆，那么在插入的过程中我们也能够轻松获得中位数。\n这个思路是可行的，我们这里再补充需要注意的一点。这两个堆并不是完全独立的，注意到左侧有向上的箭头，这说明下面的元素必须小于上面的元素，即后半截的所有元素都必须大于前半截的所有元素，不满足这个性质的话就取不到真正的中位数。\n我们是从“将一个有序数组截成两半”这样的角度来一步步引出堆的使用的。虽然，堆不能保证整个数组严格有序，但我们将这个问题简化了，现在我们只关注两个堆的最大值和最小值，其他部分是否严格有序则无关紧要。\n代码实现 我们先介绍一些通用的类变量：\nprivate static final Queue\u0026lt;Integer\u0026gt; largeQueue = new PriorityQueue\u0026lt;\u0026gt;(); private static final Queue\u0026lt;Integer\u0026gt; smallQueue = new PriorityQueue\u0026lt;\u0026gt;(((o1, o2) -\u0026gt; o2 - o1)); 这两个类变量的含义是很明显的，largeQueue对应数组的下半部分，我们取最小值，因此使用小顶堆。smallQueue对应数组的上半部分，我们取最大值，因此要使用大顶堆。\n我们给出两种实现，一种实现更复杂但能够节省运行时间，另一种实现更简洁但运行时间稍慢。\n第一种实现如下：\nprivate static void insert(int num) { if (largeQueue.isEmpty()) { largeQueue.add(num); return; } boolean isLarge = largeQueue.peek() \u0026lt; num; if (largeQueue.size() == smallQueue.size()) { if (isLarge) { largeQueue.add(num); } else { smallQueue.add(num); } } else if (largeQueue.size() \u0026gt; smallQueue.size()) { if (isLarge) { largeQueue.add(num); smallQueue.add(largeQueue.poll()); } else { smallQueue.add(num); } } else { if (isLarge) { largeQueue.add(num); } else { smallQueue.add(num); largeQueue.add(smallQueue.poll()); } } } private static double getMedian() { if (largeQueue.size() \u0026gt; smallQueue.size()) { return largeQueue.peek(); } else if (largeQueue.size() == smallQueue.size()) { if (largeQueue.isEmpty()) { return 0; } return (largeQueue.peek() + smallQueue.peek()) / 2.0; } else { return smallQueue.peek(); } } insert()的实现可以用循环不变式来描述并证明。我们维护的性质是：两个堆的元素个数最多只相差1，且smallQueue的所有值小于等于largeQueue里的所有值。\n首次插入时，不需要进行任何调整，我们直接插入任意一个堆均可。这里我们选择largeQueue。如果largeQueue不为空，我们就认为不是首次插入。显然，首次循环，性质成立。\n接下来，如果我们已经有了满足相关性质的两个堆，我们需要证明下面的插入代码依然能够维护性质。\n在第6行，我们将插入元素与右半边堆顶元素作比较，如果该元素大于它，说明我们应该将这个元素插入右半边，isLarge将为 true；否则我们应该将这个元素插入左半边，以维持性质。\n选择与largeQueue作比较是因为这个堆一定不为空，省去了判空代码。\n但在插入之前，由于我们要维护“两个堆的元素个数最多只相差1”这个性质，因此我们需要预先判断当前的元素个数，并根据这个信息来指导后续的插入操作。\n第7行至第12行，如果当前堆元素平衡，那么直接插入相应的半边；\n第13行、第20行，如果有某一边不平衡，那么在插入结束后，此半边应当将一个元素移动至另外一边，这样就维护了元素平衡的性质。\n综上，我们在循环时能够维护上述的性质，因此算法正确。\ngetMedian()比较简单，哪一个半边的元素更多就拿哪一个半边的堆顶作为中位数；否则就同时取两个堆顶并计算平均值。\n第二种实现更加简洁。在第一种实现中，在元素个数不平衡时，两个半边都有可能包含中位数。而第二种实现则固定让右半边不平衡：\nprivate static void insertRefactor(int num) { if (largeQueue.size() \u0026gt; smallQueue.size()) { largeQueue.add(num); smallQueue.add(largeQueue.poll()); } else { smallQueue.add(num); largeQueue.add(smallQueue.poll()); } } private static double getMedianRefactor() { if (largeQueue.size() \u0026gt; smallQueue.size()) { return largeQueue.peek(); } else { if (largeQueue.isEmpty()) { return 0; } return (largeQueue.peek() + smallQueue.peek()) / 2.0; } } 我们用循环不变式来证明insertRefactor()的正确性。（维护的性质：两个堆的元素个数最多只相差1，且smallQueue的所有值小于等于largeQueue里的所有值。）\n初始化：命中第5行的 else 语句，最终元素落入largeQueue，性质正确。\n循环：\n如果当前largeQueue元素更多：由于只相差1，因此先插入至largeQueue，再从largeQueue移入smallQueue可以让两者元素一样多；largeQueue移出的元素始终为最小的元素，因此，性质正确。\n如果largeQueue当前元素一样多或更少：推理同上，可证明性质正确。\n由于我们不再比较插入元素与堆顶，因此代码更简洁。\nsmallQueue的元素个数永远不可能多于largeQueue，因此getMedianRefactor()省略了一个条件分支。\n","permalink":"https://usagisang.github.io/posts/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","summary":"\u003ch2 id=\"link\"\u003elink\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/41.1%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.md\"\u003eCS-Note 41.1 数据流中的中位数\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://leetcode.cn/problems/find-median-from-data-stream/\"\u003eLeetcode 295. 数据流的中位数\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"题目描述\"\u003e题目描述\u003c/h2\u003e\n\u003cp\u003e如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\u003c/p\u003e","title":"数据流中的中位数"},{"content":" 本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki\nSELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。\n访问控制与SELinux上下文 为了说明 SELinux 到底是如何进行访问控制的，让我们来假设这样一个使用场景：现在有一名已登录的用户，向 shell 进程发送指令，要求 shell 进程读取一个文件 File。那么，SELinux 现在需要判断 shell 进程是否有权限读取文件 File。\nSELinux 进行判断的依据非常简单。首先，无论是进程还是文件，SELinux 都会维护它们的”标签“，比如说 shell 进程的”标签“是 user_t，而文件 File 的”标签“是 lib_t，然后根据它们两个的标签， SELinux 将在规则集合中寻找相应的条目，如果找到的条目为 allow，即允许访问，那么 SELinux 将放行此次访问，否则拒绝。\n这就是 SELinux 的工作原理：基于”标签“来查找匹配的规则。\n给”标签“打上双引号是因为这只是方便读者理解原理而使用的名字，它的正式称呼是 SELinux 上下文。另外，我们所述的 user_t 并不是完整的 SELinux 上下文。完整的 SELinux 上下文由以下3个部分组成（有时是4个部分）：\n第一部分是 SELinux 用户 其次是 SELinux 角色 接下来是 SELinux 类型 最后是可选部分，表示敏感度级别 比如说，一个文件的 SELinux 上下文可能会是这样的：system_u:object_r:lib_t:s0。system_u表示 SELinux 用户，object_r表示 SELinux 角色，lib_t是 SELinux 类型，最后的s0则表示敏感度级别。\n或许你已经注意到，SELinux 用户、角色、类别都有一个后缀，这只是一个命名惯例。在 SELinux 世界中，基本上可以认为，带有_u后缀的名字是在指代 SELinux 用户，带有_r后缀的名字是在指代 SELinux 角色，带有_t后缀的名字在指代 SELinux 类型。我们接下来讨论 SELinux 也会不时运用这些命名惯例，所以当你看到_t后缀的名字但没说明它是什么的时候，请不要惊讶。\n每个进程和文件都有各自的上下文，在启用了 SELinux 的系统上，如果想要查看文件或进程的 SELinux 上下文，请在调用相关命令时添加-Z参数，比如ls -Z可以显示文件的上下文，ps -Z可以显示进程的上下文。\nSELinux 使用每个字段来决定对访问的控制，我们将逐步介绍 SELinux 上下文中这些字段的具体作用。但实际上大多数规则都是围绕着 SELinux 类型来制定的，从这个角度出发，我们决定先介绍 SELinux 上下文中最重要的信息： SELinux 类型。\n类型强制规则 类型强制（Type Enforcement，简称TE）基于 SELinux 上下文中的 SELinux 类型。TE 模型是 SELinux 发挥作用的基石，构成了绝大多数 SELinux 策略。\nTE 模型规则的底层逻辑可以归结为三个单词组成的句子：\u0026quot;Subject-Access-Object\u0026quot;，即“主体-操作-客体”。\n在 SELinux 中，主体（Subject）指的是进程。操作（Access）指代的是一系列动作，比如 read、write、ioctl 等系统调用。客体（Object）指的是操作适用的系统资源，包括文件、进程、socket 等，客体是被动的，不会主动执行任何操作——当它主动执行任何操作时它就成为了主体。\n进程既可以成为主体，也可以作为客体，比如，一个进程向另一个进程发送终止信号时，进程就既是主体也是客体。\n规则底层逻辑的这三个要素体现在了具体的规则中。一个典型的 TE 规则的形式如下所示：\nkind source target:class permissions; kind——有几种选项，常用的是 allow、neverallow 和 dontaudit。allow 表示允许；neverallow 表示不允许；dontaudit 表示出现对应违规项后静默，不输出任何拒绝日志 source——规则的主体的类型。“谁在请求访问” target——客体的类型。“请求访问什么” class——类别。正在访问的客体（file、 socket、process 等）的类别 permissions——正在执行的操作（或一组操作）（例如，read、write） 一个实际的示例如下：\nallow user_t bin_t:file { read write }; 上面的规则的含义是：允许类型为 user_t 的进程，读取或写入，类型为 bin_t 而且类别（class）为 file 的客体。\n需要注意的是，由于主体和客体都拥有 SELinux 类型，为了方便区分这两者，与 SELinux 相关的文档中常常把赋予进程的 SELinux 类型称作域（domain），客体的则仍称作“类型”，我们也会延续这种习惯。\n客体需要区分类别，因为不同的系统资源所支持的操作集不同，比如，主体可以向进程但无法向文件发送信号。从这个角度来看，客体是由类型(bin_t)和类别(file)共同组成的。\n如果想查询客体有哪些类别，请执行ls /sys/fs/selinux/class\n如果想知道某一个类别的操作集，比如说 file 类别的操作集，请执行ls /sys/fs/selinux/class/file/perms/\n属性 SELinux 中常常包含上千种 SELinux 类型，因此，经常会遇到大部分主体对某个客体的权限完全一样的情况，如果规则只接受单个主体到单个客体的映射，会导致大量对同一个客体的重复定义。比如说，我们有三个类型对同一个客体的访问权限一致：\nallow trusted_app app_data_file:file { read write }; allow untrusted_app app_data_file:file { read write }; allow isolated_app app_data_file:file { read write }; 为了解决这种繁琐的重复定义问题，SELinux 支持对访问控制规则进行分组，这项特性被称为属性（attributes）。\n我们可以将域或类型分配到某一个属性，在定义访问控制规则时，可以利用属性进行定义，属性可以用在主体级别、对象级别或同时用于两者。\n属性定义以及将属性用于规则的示例如下：\n# Associate the attribute appdomain with the type untrusted_app. typeattribute untrusted_app appdomain; # Associate the attribute appdomain with the type isolated_app. typeattribute isolated_app appdomain; allow appdomain app_data_file:file { read write }; 至此，我们总结一下前面的内容。SELinux 绝大部分规则都是基于类型的规则。根据这些类型，SELinux 将授予或拒绝进程对文件的相应操作。多数情况下，在 SELinux 那冗长的上下文中我们只需要关注类型字段，而且由于完整的上下文真的太长了，下文也常常用 SELinux 类型来指代 SELinux 上下文这个概念。\n我们也可以在定义一个类型的语句中顺便定义这个类型所关联的属性。类型定义语法如下：\ntype 类型名 [alias { 别名1, 别名2 }] [, 属性1];\n中括号不是语法内容，而是表示这部分内容可写可不写。alias 表示别名部分，可以为类型赋予其他多个别名。逗号后接的内容视为属性部分，同样也可以关联多个属性。比如，下述声明语句：\ntype httpd_t, file_type, domain; 既定义了一个 SELinux 类型 httpd_t，也将 httpd_t 这个 SELinux 类型关联到属性 file_type 和 domain，它等价于下述语句：\ntype httpd_t; typeattribute httpd_t file_type, domain; 上下文继承 默认情况下，若 SELinux 中没有其他指定的策略，则新的进程和文件的 SELinux 类型是从其父级继承而来的。比如说：\n以foo_t上下文运行的进程 fork 新的子进程时，此进程的上下文也为foo_t 在上下文为bar_t的目录中创建的文件或目录也将获得bar_t上下文 如同所有的进程的源头都是 init 进程一样，追溯 SELinux 的上下文继承体系，也有一个所谓的根上下文。进程和文件的根上下文都由相应的 SELinux 策略定义。一般来说，在 Linux 中文件的根上下文是root_t，进程的根上下文是kernel_t。\n域转换 进程如何进入特定的上下文\n既然进程有根上下文，那么 SELinux 势必要支持域转换，否则所有的进程只会拥有同一个上下文。进程可以通过三种方式进行域转换：\n通过 type_transition 语句自动转换 使用 libselinux 中的 setexeccon() 使用 libselinux 中的 setcon() 第一种是为不支持 SELinux （不使用 libselinux ）且对 SELinux 一无所知的应用准备的；后两种则需要引入 libselinux 。setexeccon()函数可以指定下一次调用exec()后新进程的上下文，而setcon()最为特殊，它可以直接改变当前进程的上下文。\n无论进程采用哪一种方式，SELinux 并不会自动许可域转换，所以我们在确定好哪些域要转换后，还必须编写相应的 allow 规则来放行这些转换。\n虽然从系统的角度来看，exec()并不会诞生新进程，但我们姑且把一个进程替换自身代码段的行为称之“创建”了新进程。\ntype_transition语句 这是最常用的方式。我们知道，默认情况下，在新旧进程之间，域将原封不动地继承，但type_transition定义可以改变这种默认行为。一旦满足条件，SELinux 将根据type_transition语句决定新进程的域，域转换自动发生。\ntype_transition定义的示例如下：\ntype_transition init_t initrc_exec_t : process initrc_t; 它的含义是：当 init_t 进程执行（通过exec）上下文为 initrc_exec_t 的文件时，生成的进程应在 initrc_t 上下文中运行。在满足后面我们会提到的条件后，SELinux 将自动执行域转换。\n上面的示例展示了定义域转换所需的三个要素：原来的域，可执行文件的类型，新的域。\n采用这种方式定义域转换不存在侵入性，因而非常适合那些不方便引入 libselinux 库的程序。即使应用程序引入了 libselinux，也经常依赖type_transition语句进行自动域转换。\n使用 libselinux 中的 setexeccon() 支持 SELinux 的应用可以使用 libselinux 中的 setexeccon()，这个函数将设置用于下一个exec()调用的上下文。另外，应用必须具有 setexec 权限才能使用这个 API，例如：\nallow crond_t self:process setexec; self:process是一种特殊的客体写法，但应该不难理解，它指明客体就是主体的这个进程。\n使用 libselinux 中的 setcon() 应用还可以使用setcon()函数直接切换当前进程的上下文。和setexeccon()一样，进程执行setcon()也需要一个特殊的 SELinux 权限setcurrent。\nallow crond_t self:process setcurrent; 使用这个 API 有一些额外的限制，比如，如果应用使用多线程，那么必须在创建任何子线程之前执行setcon()，这种情况下后续创建的所有子线程都将继承新的上下文。但是如果调用setcon()时同一进程中还有其他线程在运行，此调用将失败。\n域转换许可规则 如果域转换最终需要执行exec()才生效（对应第一种和第二种域转换方式），那么，我们就需要添加三条 allow 规则来许可域转换。这些策略用来满足以下三个条件：\n原始域对文件具有执行权限 文件上下文本身被标识为目标域的入口点（entrypoint） 允许原始域转换到目标域 我们以initrc_t进程通过执行sshd_exec_t文件来转换到sshd_t这个域为例。\n首先，exec()调用需要指定某个可执行文件，这当然需要授予一个允许进程执行文件的权限。比如，允许initrc_t进程执行sshd_exec_t文件：\nallow initrc_t sshd_exec_t : file { read getattr execute open } ; 然后，SELinux 并不知道sshd_exec_t文件和sshd_t域之间到底有什么关系，因此我们需要添加一条规则来告诉 SELinux，执行sshd_exec_t文件时，可以将域转换到sshd_t。这种特性被我们称之为 entrypoint，定义的方式为，在通常的 allow 规则中，主体sshd_t对客体sshd_exec_t的操作集中添加 entrypoint，示例如下：\nallow sshd_t sshd_exec_t:file { ioctl read getattr lock execute execute_no_trans open entrypoint }; 由于“主体-操作-客体”的 SELinux 底层逻辑的限制，我们没办法以客体为主语，因此 entrypoint 的 allow 规则显得比较抽象，遇到 entrypoint 时，试着反过来理解 allow 规则，逻辑会更顺畅。\n最后，我们还需要告诉 SELinux，允许从initrc_t域转换到sshd_t域。\nallow initrc_t sshd_t:process transition; 为什么我们最后需要定义一个 allow 规则来允许一个域向另一个域转换？这是因为一个文件可以成为多个域的 entrypoint，比如说，sshd_exec_t同时还是xm_ssh_t域和ssh_t域的 entrypoint。因此，SELinux 不允许一个域获得一个文件的执行权限就可以根据 entrypoint 定义转换到其他所有域， SELinux 要求明确指出，从哪个域到哪个域的转换才是被允许的。\n如果应用使用setcon()直接切换本进程的上下文，那么，我们需要添加对目标上下文的dyntransition操作的 allow 规则，表明一个上下文可以“动态”切换到目标上下文。\nallow adbd su:process dyntransition; 这是 Android 中的 SELinux 规则的一个例子，它表明在 adbd 域中的进程可以动态切换到 su 域中。\n客体的类型转换 和进程间的域转换类似，我们也可以为客体定义相应的类型转换语句，让 SELinux 在满足相应条件后自动执行类型转换。例如，现在有一个域为ext_gateway_t的进程，希望在类型为in_queue_t的文件夹内保存文件时，该文件的类型不继承父目录的类型，而是使用另一个类型in_file_t。示例的定义语句如下：\ntype_transition | source_domain | target_type : object ----------------▼---------------▼--------------▼----------------- type_transition ext_gateway_t in_queue_t : file in_file_t; 这个 type_transition 语句的含义是，当在ext_gateway_t域（source_domain） 中运行的进程想要在类型为in_queue_t的目录中创建file对象时，如果策略允许，则应将该文件重新标记为in_file_t\n为了能够创建文件，我们还需要在 SELinux 中添加相应的 allow 规则。\n源域需要有权限将file添加到in_queue_t目录中\nallow ext_gateway_t in_queue_t:dir { write search add_name }; 源域需要有创建in_file_t文件的权限\nallow ext_gateway_t in_file_t:file { write create getattr }; SELinux上下文与其他安全模型 我们已经围绕着 TE 模型及其规则介绍了许多内容，相信你已经体会到它的强大之处。靠着 TE 模型，SELinux 似乎已经可以工作得很好，但人类的需求总是复杂多变。不同于 TE 模型的设计思路，人类经常以用户、角色、项目等比较抽象的概念来管理权限。SELinux 为这些希望使用不同安全模型的需求提供了直接的支持，实际上，安全上下文中我们尚未介绍到的那些字段全都是用来支持其他安全模型的。\nSELinux 角色与 SELinux 用户直接支持了 RBAC （Role-Based Access Control，基于角色的访问控制）模型；SELinux 敏感度级别则支持了 MCS（Multi-Level Security）和 MLS（Multi-Category Security）模型。\n这些名词你可能很熟悉也可能很陌生，我们稍后会解释这些名词的含义。但重要的是要理解，这些安全模型都是建立在 TE 模型之上的额外的“高级”模型，只有通过 SELinux 类型的检查后，SELinux 上下文的其他部分才会继续发挥作用。SELinux 提供这些功能只是为了便于人类进行管理，但不使用它们，SELinux 也能正常运行。\n角色与RBAC模型 首先，需要说明的一点是，SELinux 角色只针对主体，对客体（文件）来说没有意义，因此，如果你使用ls -Z来查看文件的角色，你会发现它们清一色都是object_r。这个字符串只是因 SELinux 上下文不能缺少角色字段而存在的一个占位符，将进程更改为以 object_r 角色运行或尝试为文件分配不同的角色始终会被内核拒绝。\n那么，SELinux 中的角色与主体的访问控制之间有什么联系呢？为了回答这个问题，我们首先捋清楚 Linux 用户、SELinux 用户、SELinux 角色和域（SELinux 类型）之间的关系，如下图所示。\nSELinux 用户与 Linux 用户不同，它是一个独立的概念。在 SELinux 中，每个 Linux 用户都必须映射到且只能映射到一个 SELinux 用户，但支持多个 Linux 用户映射到同一个 SELinux 用户上；SELinux 用户与 SELinux 角色则是一种多对多的关系，每个 SELinux 用户都可以持有多个角色；而对于每一个 SELinux 角色来说，它们可以关联到不同的域。\n这种关联是在规定 SELinux 角色可以进入哪些域（上下文）。当然，用户控制的进程需要先通过域转换这一关， SELinux 角色的限制则在于，即使被允许转换到目标域，如果该域未附加到相应角色，转换也会失败。\n我们举一个例子说明这一点：\n假设一名开发人员试图从命令行启动 mysql 守护进程。我们知道，shell 进程被允许执行mysqld_exec_t文件并进行域转换，新的守护进程的上下文应该是mysqld_t，但不巧的是，这名人员的角色是user_r而不是数据管理员dbadm_r，mysqld_t这个域只与数据管理员关联，而没有关联到user_r这个角色上，因此本次操作将被 SELinux 阻止。\n总的来说，角色进一步限制了用户能够与哪些进程打交道。\nRBAC模型 SELinux 角色可以用于实现 RBAC （Role-Based Access Control，基于角色的访问控制），RBAC 是一种抽象的访问控制模型， 核心理念是：\n权限始终通过角色授予，不直接分配给用户 必须明确授予用户相应角色，没有角色，就没有权限 MLS与MCS 我们介绍 SELinux 上下文中的最后那一部分：敏感度级别。其实在之前的示例中，我们没有完整展现这一部分的内容，实际上敏感度级别分为两个维度的内容，分别是秘密等级和类别集。比如说下面的上下文：\nuser_u:user_r:user_t:s0:c0,c1\ns0表示秘密等级，c0,c1表示类别集是0和1。\n秘密等级可以看作对现实中的秘密等级的抽象实现。如果你了解《中华人民共和国保守国家秘密法》，应该知道所谓的“国家秘密”分为三种：绝密、机密和秘密。体现到 SELinux 上，我们可以规定，s3 表示绝密，s2 表示机密，s1 表示秘密，s0 表示公开。这样一来，即使 SELinux 类型允许进程访问高等级秘密文件，但由于秘密等级不匹配，进程依旧会读取失败。比如说，对于 s2 的进程来说，它可以读取 s2 或更低级别的文件，但无法读取更高级别比如 s3 文件。秘密等级实现了所谓的多级安全性（Multi-Level Security，MLS）。\n结合上面的秘密等级，类别集可以理解为，我们有两个秘密等级相同的项目，比如有两个 s3 绝密项目，虽然它们秘密等级相同，我们也不希望这两个项目之间的人员（进程）互相查看对方的资料（文件），因此，我们使用类别来区分这两个项目。比如说，项目 X 被划分到c0，项目 Y 被划分到c1，那么，持有s3:c0的进程可以访问项目 X 的文件，但无法访问项目 Y 的文件了。SELinux 使用类别集，实现了所谓的多类别安全性（Multi-Category Security，MCS）。\n最后，我们说明一下这部分上下文的一些特殊形式。对于秘密等级，可以使用-符号来表示范围，比如s0-s2就表示从 s0 到 s2 的等级。对于类别集，可以使用.符号来表示范围，比如c0.c15表示从类别集 c0 到 c15。\n拒绝日志 本节简单介绍一下 SELinux 拒绝日志里面包含了什么内容，至于如何根据拒绝日志添加 SELinux 策略，这是一个比较复杂的问题，本节不会讨论。\n在查看拒绝信息之前，我们需要注意以下几点：\n在日志中发现的拒绝并非都是大问题。有些拒绝只是表面上发生了，但不会影响应用程序的行为。这通常是由于应用程序开发不当（例如未正确关闭文件描述符）或由于高级库函数（应用程序仅使用了一小部分功能）造成的。 拒绝一出现就会被记录下来。这意味着在日志中我们将看到大量的拒绝，尽管许多拒绝彼此相关（一个拒绝导致另一个拒绝），但大部分拒绝与正在调查的问题无关。 如果连续出现太多拒绝，Linux 内核可能会抑制这些拒绝。因此可能看不到 SELinux 报告的所有内容。 dontaudit会抑制拒绝日志的输出，因此，不要太依赖日志，必要的时候请 review 相应的 SELinux 策略。 拒绝日志的示例如下：\navc: denied { open } for pid=1003 comm=”mediaserver” path=\u0026#34;/dev/kgsl-3d0” dev=\u0026#34;tmpfs\u0026#34; scontext=u:r:mediaserver:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=1 下表给出了每一部分日志的解释\n日志 描述 avc: 告知用户这是哪种类型的日志条目。在本例中，这是 AVC 日志条目。 denied SELinux 最终的反应，可以是 denied 或 granted。注意，如果 SELinux 处于宽容模式，尽管实际没有拒绝，在日志中依然会被记录 denied { open } 试图执行的操作，有时会包含一组操作，如{ read write } pid=1003 进程 pid comm=”mediaserver” 进程命令（不带参数，且限制为 15 个字符），帮助用户在进程已经死亡的情况下识别该进程是什么 path= 目标的绝对路径。注意，此字段很大程度上取决于目标类别，因此可能是path=、name=、capacity=、src= 等等 dev=\u0026ldquo;tmpfs\u0026rdquo; 目标所在的设备 scontext= 进程的上下文（域） tcontext= 目标资源（本例中为文件）的上下文 tclass= 目标的类别 permissive=1 表示是否允许此次操作，为1表示允许 本文的SELinux策略语法 SELinux 有两套策略语言，分别是 CIL 策略语言和内核策略语言。本文所展示的 SELinux 策略代码均基于内核策略语言。\n","permalink":"https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 \u003ca href=\"https://wiki.gentoo.org/wiki/SELinux\"\u003ewiki\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eSELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。\u003c/p\u003e","title":"SELinux快速入门"},{"content":"欧几里得算法的自然语言描述 计算两个非负整数p和q的最大公约数：若 q 是0，则最大公约数为p。否则，将 p 除以 q 得到余数 r，p和q的最大公约数即为 q 和 r 的最大公约数。\n递归实现 根据自然语言描述实现递归的 gcd 算法是比较容易的：\nint gcd(int p, int q) { if (q == 0) { return p; } int r = p % q; return gcd(q, r); } 非递归实现 由于递归版本的 gcd 是一个尾递归函数，因此改写为迭代版本的实现相对也较为容易。\n我们分析一下。gcd 算法的停止条件应当是余数为0。而在计算的过程中，我们一般需要三个变量的空间，用于存放 p、q 和它们的计算结果 r，如果计算仍需进行，我们需要将 q 的值移动至 p，r 的值移动至 q，这样就维护了p % q计算循环的正确性：\nint gcd(int p, int q) { int r = q; while (r != 0) { r = p % q; p = q; q = r; } return p; } 减少一个变量 上面的算法是不是可以减少一个变量的使用呢？\n如果我们不使用一个新变量 r 来存放p%q的计算结果，那么这个结果必须放在 p 或 q 所在的内存中。在上面的实现中，我们最终是要用 q 将 p 的值覆盖掉的，说明 p 的值在计算后变得不重要了，我们直接用计算结果覆盖：p = p % q\n那么，计算结果 r 现在放在p这个变量上，它需要和q交换一下位置。通用的交换算法需要用到三个变量，似乎我们依然无法避免多声明一个变量？未必，因为 gcd 算法使用的是整型变量，我们可以使用一种只有整型变量能使用的特殊技巧来交换二者的值。\n利用XOR交换两个整型变量 按位进行 XOR（异或运算）的规则很简单，若两个操作数相应的位不同则值为1，相同则值为0，比如 15 XOR 19：\n00001111 XOR 00010011 = 00011100 异或运算的本质是求出两个操作数在每一个位上的 diff 信息\n由于位只有两种状态，因此，一个操作数结合 diff 信息，得到另一个操作数是轻而易举的事情——只需要再进行一次异或。用简单的等式（注意不是赋值语句）来表示，即b=a^b^a。\n用扩展的角度来看，a、b、a^b 之间形成一种三角关系：a^b 代表 a 与 b 的 diff 信息，而 b 代表了 a 和 a^b 的 diff 信息，a 代表了 b 和 a^b 的 diff 信息。\n因而，只要我们知道这个三角关系的任意两个值，都可以计算得出第三个值。（异或的逆运算是自身）\n有两种角度理解 XOR：\n其一是从生成两个操作数的 diff 信息这个角度来理解，即，不同为1，相同为0\n其二是操作数根据 diff 信息还原出另一个操作数的角度来理解。我们把 diff 的每一个位理解成：若 diff 的某一位是0，说明希望保持这个位；若 diff 的某一位是 1，说明希望翻转这个位。\n根据异或运算的特点，我们可以做到只使用两个变量来交换两个整型：\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a^b; b = a^b; // 相当于a^b^b a = a^b; // 相当于a^b^a } 二元运算与整型变量交换 如何理解上面的代码呢？我们换个更简单的二元运算——加法，来进一步说明这个问题。使用加法来交换两个整型更加直观且直接（我们不这么做的理由是加法可能会导致结果溢出，因此显得不如异或可靠）\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a + b; // 先计算一个同时包含a和b的结果 b = a - b; // 通过b进行逆运算, 求原来的a a = a - b; // 通过原来的a进行逆运算，求原来的b } 仔细对比使用异或运算或加减法运算对整型变量进行交换的步骤，我们可以更清楚地知道二元运算是怎么产生作用的。\n首先，我们用可逆的二元运算，计算出一个同时包含操作数 a 和 b 的结果，然后使用逆运算还原想要的另一个操作数即可达成变量交换的效果。对于异或运算来说，它的逆运算就是其自身。\n另一个版本的gcd 我们知道如何使用二元运算交换整型变量后，照葫芦画瓢修改原来的 gcd 算法即可：\nint gcd_no(int p, int q) { while (q != 0) { p = p % q; p = p^q; q = p^q; p = p^q; } return p; } 这个算法会更高效吗？答案是未必，它虽然减少了一个栈变量的使用，但是却可能增加了一次内存访问。\n","permalink":"https://usagisang.github.io/posts/gcd%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"欧几里得算法的自然语言描述\"\u003e欧几里得算法的自然语言描述\u003c/h2\u003e\n\u003cp\u003e计算两个非负整数p和q的最大公约数：若 q 是0，则最大公约数为p。否则，将 p 除以 q 得到余数 r，p和q的最大公约数即为 q 和 r 的最大公约数。\u003c/p\u003e\n\u003ch2 id=\"递归实现\"\u003e递归实现\u003c/h2\u003e\n\u003cp\u003e根据自然语言描述实现递归的 gcd 算法是比较容易的：\u003c/p\u003e","title":"gcd的递归与非递归实现"},{"content":"本文以 android-12.0.0_r34 的代码进行分析。\nframework中的JNI 通常来说，Android framework 中使用到的 native 函数都是动态注册的，而且注册过程有固定的套路。我们以Parcel类为例来解析套路。\n首先，我们在Parcel.java中会看到很多标记为 native 的方法（为了便于演示，去掉了很多 native 方法）：\npublic final class Parcel { private static native long nativeCreate(); private static native long nativeFreeBuffer(long nativePtr); private static native void nativeDestroy(long nativePtr); } 然后，你可以在 Android 源码中找到相应的 jni 定义：\n// frameworks/base/core/jni/android_os_Parcel.cpp #include \u0026#34;core_jni_helpers.h\u0026#34; namespace android { static struct parcel_offsets_t { jclass clazz; jfieldID mNativePtr; jmethodID obtain; jmethodID recycle; } gParcelOffsets; static jlong android_os_Parcel_create(JNIEnv* env, jclass clazz) { Parcel* parcel = new Parcel(); return reinterpret_cast\u0026lt;jlong\u0026gt;(parcel); } static void android_os_Parcel_freeBuffer(JNIEnv* env, jclass clazz, jlong nativePtr) { Parcel* parcel = reinterpret_cast\u0026lt;Parcel*\u0026gt;(nativePtr); if (parcel != NULL) { parcel-\u0026gt;freeData(); } } static void android_os_Parcel_destroy(JNIEnv* env, jclass clazz, jlong nativePtr) { Parcel* parcel = reinterpret_cast\u0026lt;Parcel*\u0026gt;(nativePtr); delete parcel; } } // ---------------------------------------------------------------------------- static const JNINativeMethod gParcelMethods[] = { {\u0026#34;nativeCreate\u0026#34;, \u0026#34;()J\u0026#34;, (void*)android_os_Parcel_create}, {\u0026#34;nativeFreeBuffer\u0026#34;, \u0026#34;(J)V\u0026#34;, (void*)android_os_Parcel_freeBuffer}, {\u0026#34;nativeDestroy\u0026#34;, \u0026#34;(J)V\u0026#34;, (void*)android_os_Parcel_destroy}, }; const char* const kParcelPathName = \u0026#34;android/os/Parcel\u0026#34;; int register_android_os_Parcel(JNIEnv* env) { jclass clazz = FindClassOrDie(env, kParcelPathName); gParcelOffsets.clazz = MakeGlobalRefOrDie(env, clazz); gParcelOffsets.mNativePtr = GetFieldIDOrDie(env, clazz, \u0026#34;mNativePtr\u0026#34;, \u0026#34;J\u0026#34;); gParcelOffsets.obtain = GetStaticMethodIDOrDie(env, clazz, \u0026#34;obtain\u0026#34;, \u0026#34;()Landroid/os/Parcel;\u0026#34;); gParcelOffsets.recycle = GetMethodIDOrDie(env, clazz, \u0026#34;recycle\u0026#34;, \u0026#34;()V\u0026#34;); return RegisterMethodsOrDie(env, kParcelPathName, gParcelMethods, NELEM(gParcelMethods)); } }; 首先，我们会发现 Java 层定义的 native 方法的名字中都带有 native 前缀，但实际上，它们对应的 cpp 函数的名称都不会带有 native 前缀。\n其次，源码中习惯上会使用一个全局 static 数组来统一存放 cpp 函数与 Java 层定义的映射，然后，再定义一个register_xxx的函数，此函数内部一般执行两件事，第一件是完成这个文件内所有 JNI 函数的动态注册；第二件是提前使用JNIEnv找到后续 cpp 函数回调 Java 层时可能要用到的jclass、jfieldID或jmethodID，这些信息会保存在另一个全局结构体中。\nRegisterMethodsOrDie 动态注册的关键在于RegisterMethodsOrDie这个函数，这个函数实际上来自于frameworks/base/core/jni/core_jni_helpers.h（正因为在同一个目录下，因此 include 的时候使用了双引号）\n// frameworks/base/core/jni/core_jni_helpers.h #include \u0026lt;android_runtime/AndroidRuntime.h\u0026gt; namespace android { static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods); LOG_ALWAYS_FATAL_IF(res \u0026lt; 0, \u0026#34;Unable to register native methods.\u0026#34;); return res; } } 我们继续追踪AndroidRuntime.h，这个头文件位于frameworks/base/core/jni/include/android_runtime/AndroidRuntime.h，实现位于frameworks/base/core/jni/AndroidRuntime.cpp\n// frameworks/base/core/jni/AndroidRuntime.cpp #include \u0026lt;nativehelper/JNIHelp.h\u0026gt; namespace android { /* * Register native methods using JNI. */ /*static*/ int AndroidRuntime::registerNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { return jniRegisterNativeMethods(env, className, gMethods, numMethods); } } jniRegisterNativeMethods这个方法实际上由JNIHelp.h导入，实现位于libnativehelper/JNIHelp.c\n// libnativehelper/JNIHelp.c int jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* methods, int numMethods) { ALOGV(\u0026#34;Registering %s\u0026#39;s %d native methods...\u0026#34;, className, numMethods); jclass clazz = (*env)-\u0026gt;FindClass(env, className); ALOG_ALWAYS_FATAL_IF(clazz == NULL, \u0026#34;Native registration unable to find class \u0026#39;%s\u0026#39;; aborting...\u0026#34;, className); int result = (*env)-\u0026gt;RegisterNatives(env, clazz, methods, numMethods); (*env)-\u0026gt;DeleteLocalRef(env, clazz); if (result == 0) { return 0; } // 剩下的代码与失败处理相关, 省略 // ... ALOGF(\u0026#34;RegisterNatives failed for \u0026#39;%s\u0026#39;; aborting...\u0026#34;, className); return result; } 何时调用register 摸清楚了 Android framework 如何动态注册 JNI，另一个问题便是 framework 会在什么时候调用相应的 register 函数呢？答案依然在frameworks/base/core/jni/AndroidRuntime.cpp中。\n首先，我们会在 AndroidRuntime.cpp 中看到 extern 声明和一个全局数组：\n// frameworks/base/core/jni/AndroidRuntime.cpp using namespace android; // 不定义在android这个命名空间内的register函数, 数量不少, 这里仅展示一小部分 extern int register_android_opengl_jni_EGL14(JNIEnv* env); extern int register_android_opengl_jni_EGL15(JNIEnv* env); extern int register_android_opengl_jni_EGLExt(JNIEnv* env); // ... namespace android { /* * JNI-based registration functions. Note these are properly contained in * namespace android. */ // 省略... extern int register_android_os_MessageQueue(JNIEnv* env); extern int register_android_os_Parcel(JNIEnv* env); // 省略... // 定义了REG_JNI, 如果没开启debug, 这个结构体就不会存储名字 #ifdef NDEBUG #define REG_JNI(name) { name } struct RegJNIRec { int (*mProc)(JNIEnv*); }; #else #define REG_JNI(name) { name, #name } struct RegJNIRec { int (*mProc)(JNIEnv*); const char* mName; }; #endif static const RegJNIRec gRegJNI[] = { REG_JNI(register_android_os_Parcel), REG_JNI(register_android_opengl_jni_EGL14), REG_JNI(register_android_opengl_jni_EGL15), REG_JNI(register_android_opengl_jni_EGLExt), REG_JNI(register_android_os_MessageQueue) }; } gRegJNI这个数组基本上约等于存放了一堆 lambda，等待Android 虚拟机启动时，直接遍历该数组就可以完成注册。其调用链大致为：start -\u0026gt; startReg -\u0026gt; register_jni_procs\n// frameworks/base/core/jni/AndroidRuntime.cpp /* * Start the Android runtime. This involves starting the virtual machine * and calling the \u0026#34;static void main(String[] args)\u0026#34; method in the class * named by \u0026#34;className\u0026#34;. * * Passes the main function two arguments, the class name and the specified * options string. */ void AndroidRuntime::start(const char* className, const Vector\u0026lt;String8\u0026gt;\u0026amp; options, bool zygote) { // ... JNIEnv* env; if (startVm(\u0026amp;mJavaVM, \u0026amp;env, zygote, primary_zygote) != 0) { return; } onVmCreated(env); /* * Register android functions. */ if (startReg(env) \u0026lt; 0) { ALOGE(\u0026#34;Unable to register all android natives\\n\u0026#34;); return; } // ... } /* * Register android native functions with the VM. */ /*static*/ int AndroidRuntime::startReg(JNIEnv* env) { ATRACE_NAME(\u0026#34;RegisterAndroidNatives\u0026#34;); /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\u0026#34;--- registering native functions ---\\n\u0026#34;); /* * Every \u0026#34;register\u0026#34; function calls one or more things that return * a local reference (e.g. FindClass). Because we haven\u0026#39;t really * started the VM yet, they\u0026#39;re all getting stored in the base frame * and never released. Use Push/Pop to manage the storage. */ env-\u0026gt;PushLocalFrame(200); if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) \u0026lt; 0) { env-\u0026gt;PopLocalFrame(NULL); return -1; } env-\u0026gt;PopLocalFrame(NULL); //createJavaThread(\u0026#34;fubar\u0026#34;, quickTest, (void*) \u0026#34;hello\u0026#34;); return 0; } static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env) { for (size_t i = 0; i \u0026lt; count; i++) { if (array[i].mProc(env) \u0026lt; 0) { #ifndef NDEBUG ALOGD(\u0026#34;----------!!! %s failed to load\\n\u0026#34;, array[i].mName); #endif return -1; } } return 0; } ","permalink":"https://usagisang.github.io/posts/android-framework%E4%B8%8Ejni/","summary":"\u003cp\u003e本文以 android-12.0.0_r34 的代码进行分析。\u003c/p\u003e\n\u003ch2 id=\"framework中的jni\"\u003eframework中的JNI\u003c/h2\u003e\n\u003cp\u003e通常来说，Android framework 中使用到的 native 函数都是动态注册的，而且注册过程有固定的套路。我们以\u003ccode\u003eParcel\u003c/code\u003e类为例来解析套路。\u003c/p\u003e","title":"Android Framework与JNI"},{"content":" https://source.android.com/docs/devices/admin\nhttps://developer.android.com/work/guide\nhttps://developers.google.com/android/work/play/emm-api/prov-devices\n本文提到的“设备管理”并不面向终端用户，而是一种支持企业管理、监控和保护所有用于工作的移动设备的实际需要而产生的一系列框架。\n关键术语\nDevice Policy Controller：设备政策控制器，简称 DPC Device Owner：设备所有者，是 Android 设备管理框架运行的一种模式，有时简称为 DO Profile Owner：工作配置所有者，是 Android 设备管理框架运行的一种模式，有时简称为 PO 设备管理方案 一套完整的设备管理方案通常包含了两个方面的支持。其一是安装在设备端的设备政策控制器（Device Policy Controller）应用，其二是云端的控制台。企业客户在设备上安装 DPC 应用并与云端关联注册后，可以通过云端将设备管理政策下发至 DPC 应用，DPC 应用最终执行之。\nDPC 应用的运行模式 Android 提供了以下三种设备管理模式，其中一种已在 9.0 后废弃，无法再使用。\nDevice Owner（设备所有者）\nDPC 应用成为设备所有者，用于管理整个设备。这是权限最高的模式，一旦开启，除非 DPC 应用主动注销自己，否则只能通过恢复出厂设置来重置。\nProfile Owner（工作配置所有者）\nDPC 应用被设置为 Profile Owner。启用这个模式后，相当于系统开启一个额外的工作分区，工作分区和个人分区的内容互不影响，DPC 应用只有管理工作分区的权限。该设备依然可以用于个人用途。此类设备管理主要用于个人和组织同时持有的设备。权限比 Device Owner 低。\nDevice Admin，此模式在 9.0 中被废弃并在 10.0 中完全移除相应功能。\n成为Device Owner 前提条件：\n需要成为 Device Owner 的应用必须包含继承android.app.admin.DeviceAdminReceiver的组件。假设自定义的组件名为TestReceiver。\n通过二维码，必须在开机向导结束前设置。\nGoogle 没有具体提供采用这种方式激活成为 Device Owner 的详细步骤，据测试，使用下述 intent 可以启动ManagedProvisioning框架\nam start -a android.app.action.PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE --ecn android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME \u0026#34;packageName/.TestReceiver\u0026#34; 通过 adb shell\n使用如下命令：\nadb shell dpm set-device-owner packageName/.TestReceiver 通过 NFC\n通过二维码注册为 Device Owner 根据Google Play EMM API，我们可以总结出通过二维码注册 Device Owner 的主要流程。\n准备二维码 二维码的内容应当是一个采用 UTF-8 编码的 JSON 字符串，内部包含一些参数。这些参数包括：\n必须\nandroid.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\n如果未安装 DPC，则必须提供下载路径和校验码\nandroid.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\nandroid.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\n更多参数请参考上述资料。\n一个可用的二维码内容的示例：\n{ \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME\u0026#34;: \u0026#34;com.emm.android/com.emm.android.DeviceAdminReceiver\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM\u0026#34;: \u0026#34;gJD2YwtOiWJHkSMkkIfLRlj-quNqG1fb6v100QmzM9w=\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_DEVICE_ADMIN_PACKAGE_DOWNLOAD_LOCATION\u0026#34;: \u0026#34;https://path.to/dpc.apk\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_SKIP_ENCRYPTION\u0026#34;: false, \u0026#34;android.app.extra.PROVISIONING_WIFI_SSID\u0026#34;: \u0026#34;GuestNetwork\u0026#34;, \u0026#34;android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE\u0026#34;: { \u0026#34;dpc_company_name\u0026#34;: \u0026#34;Acme Inc.\u0026#34;, \u0026#34;emm_server_url\u0026#34;: \u0026#34;https://server.emm.biz:8787\u0026#34;, \u0026#34;another_custom_dpc_key\u0026#34;: \u0026#34;dpc_custom_value\u0026#34; } } 扫码 扫码模块必须是开机向导的一部分，开机向导完成后就无法通过二维码的方式设置 Device Owner。\n扫码模块在解析完毕 JSON 内所有参数后，发送一个 Intent。Intent 的 action 应当是DevicePolicyManager#ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE，extra则携带解析 JSON 获得的参数。\nManagedProvisioning 相应的 Intent 将会启动ManagedProvisioning应用。如果 DPC 应用尚未安装到设备上，那么ManagedProvisioning会负责下载并安装 DPC 应用，前提是提供了下载路径和校验码这两个关键参数。\n当应用已安装到设备上，ManagedProvisioning接下来的行为与 Android 版本相关。我们只讨论 Android 10 及以上的平台版本。\n在 Android 10 及以上的平台版本，ManagedProvisioning将会交由 DPC 应用来决定（实际上是要求用户决定）成为 Device Owner 还是 Profile Owner。ManagedProvisioning将会进行一次startActivityForResult，ACTION 为DevicePolicyManager#ACTION_GET_PROVISIONING_MODE。\nDPC应用 一般来说收到 Intent 后，DPC 应用应该展示一个界面，让用户选择 DPC 应用成为 Device Owner 或 Profile Owner ，结果回传的 key 可以参阅DevicePolicyManager#ACTION_GET_PROVISIONING_MODE的文档。\n最后的步骤 ManagedProvisioning将会完成使能 Device Owner 或 Profile Owner 的最后步骤。\n设备配置后，DPC 会收到以下这些广播：\nDeviceAdminReceiver#ACTION_READY_FOR_USER_INITIALIZATION DeviceAdminReceiver#ACTION_PROFILE_PROVISIONING_COMPLETE 并且 DPC 的 DevicePolicyManager#ACTION_ADMIN_POLICY_COMPLIANCE 处理程序会被启动。\n低平台版本的行为\n在 Android 9 及以下的平台版本，ManagedProvisioning将会自动判断到底将 DPC 应用设置为 Device Owner 还是 Profile Owner。判断的依据是ProvisioningParams#provisioningAction\n// packages/apps/ManagedProvisioning/src/com/android/managedprovisioning/preprovisioning/PreProvisioningController.java // Android 9 public boolean isProfileOwnerProvisioning() { // mParams类型为ProvisioningParams return mUtils.isProfileOwnerAction(mParams.provisioningAction); } // packages/apps/ManagedProvisioning/src/com/android/managedprovisioning/common/Utils.java // Android 9 public final boolean isProfileOwnerAction(String action) { return ACTION_PROVISION_MANAGED_PROFILE.equals(action) || ACTION_PROVISION_MANAGED_USER.equals(action); } public final boolean isDeviceOwnerAction(String action) { return ACTION_PROVISION_MANAGED_DEVICE.equals(action) || ACTION_PROVISION_MANAGED_SHAREABLE_DEVICE.equals(action); } 这个 ACTION 一般来说和启动它的 Intent 的 ACTION 一致，但有几个特殊的 ACTION 会被转换，ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE就是其中一例：\n// packages/apps/ManagedProvisioning/src/com/android/managedprovisioning/common/Utils.java // Android 9 public String mapIntentToDpmAction(Intent intent) throws IllegalProvisioningArgumentException { // ... switch (intent.getAction()) { case ACTION_PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE: dpmProvisioningAction = ACTION_PROVISION_MANAGED_DEVICE; break; } // ... } 因此，启动 DPC 应用这一步将被省略，并且也不会发送ACTION 为DevicePolicyManager#ACTION_ADMIN_POLICY_COMPLIANCE 的 Intent。\n流程梳理 我们的主要分析目标是ManagedProvisioning这个应用，它是 AOSP 的一部分，与设备管理功能强关联。\n开始 流程的第一步是发送一个 Intent 以启动ManagedProvisioning，ACTION 有四种选择，这些ACTION 均可在DevicePolicyManager中被找到：\nandroid.app.action.PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE android.app.action.PROVISION_FINANCED_DEVICE android.app.action.PROVISION_MANAGED_PROFILE android.app.action.PROVISION_MANAGED_DEVICE 这四个 ACTION 到底有什么区别呢？主要的区别在于，前两个 ACTION 是给系统应用使用的；后两个 ACTION 是给 DPC 应用使用的，但在 API 31 （Android 12）及以后，PROVISION_MANAGED_DEVICE被弃用了。DPC 应用现在只能主动成为 Profile Owner，ManagedProvisioning虽然还会响应PROVISION_MANAGED_DEVICE ，但是添加了一个条件分支阻止进一步使能为 DO。\n携带的 extra 参数的要求可以参考相应 ACTION 的文档。一般来说都需要携带android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME这个参数来指明组件。\n测试脚本：\nam start -a android.app.action.PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE --ecn android.app.extra.PROVISIONING_DEVICE_ADMIN_COMPONENT_NAME \u0026#34;com.afwsamples.testdpc/.DeviceAdminReceiver\u0026#34; PreProvisioningActivity 从清单中很容易能够发现，PreProvisioningActivity响应了ACTION_PROVISION_MANAGED_PROFILE和ACTION_PROVISION_MANAGED_DEVICE：\n\u0026lt;activity android:name=\u0026#34;.preprovisioning.PreProvisioningActivity\u0026#34; android:excludeFromRecents=\u0026#34;true\u0026#34; android:immersive=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;singleTop\u0026#34; android:exported=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/SudThemeGlifV3.DayNight\u0026#34;\u0026gt; \u0026lt;intent-filter android:priority=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.app.action.PROVISION_MANAGED_PROFILE\u0026#34; /\u0026gt; \u0026lt;action android:name=\u0026#34;android.app.action.PROVISION_MANAGED_DEVICE\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 但其实不太容易发现这个 Activity 同时还响应了前面所提到的其他 ACTION，清单中定义了一个不太常见的别名结构，根据注释来看，这个别名添加了一个 system 应用才能申请的权限，主要是为了限制这两个 ACTION 只给特权应用使用\n\u0026lt;!-- Trusted app entry for device owner provisioning, protected by a permission so only privileged app can trigger this. --\u0026gt; \u0026lt;activity-alias android:name=\u0026#34;.PreProvisioningActivityViaTrustedApp\u0026#34; android:targetActivity=\u0026#34;.preprovisioning.PreProvisioningActivity\u0026#34; android:permission=\u0026#34;android.permission.DISPATCH_PROVISIONING_MESSAGE\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter android:priority=\u0026#34;10\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.app.action.PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;android.app.action.PROVISION_FINANCED_DEVICE\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity-alias\u0026gt; PreProvisioningActivity对 Intent 参数处理的初始化逻辑大部分位于PreProvisioningActivityController#initiateProvisioning\npublic void initiateProvisioning(Intent intent, String callingPackage) { // 尝试将Intent中携带的参数解析为ProvisioningParams // 解析通过ViewModel转接到Parser, 因此下文会从ViewModel中获取解析好的对象 if (!tryParseParameters(intent)) { return; } ProvisioningParams params = mViewModel.getParams(); // 检查是否存在不允许恢复出厂设置的保护 if (!checkFactoryResetProtection(params, callingPackage)) { return; } // 检查CallerPackage是否合法，这里阻止了非DPC应用发送PROVISION_MANAGED_DEVICE和PROVISION_MANAGED_PROFILE这两个ACTION if (!verifyActionAndCaller(intent, callingPackage)) { return; } // Check whether provisioning is allowed for the current action. This check needs to happen // before any actions that might affect the state of the device. // Note that checkDevicePolicyPreconditions takes care of calling // showProvisioningErrorAndClose. So we only need to show the factory reset dialog (if // applicable) and return. // 重要函数, 实际上调用了DevicePolicyManager#checkProvisioningPreCondition // 检查是否真的可以启用设备管理功能 if (!checkDevicePolicyPreconditions()) { return; } // Android 12以后额外添加的分支，彻底阻止PROVISION_MANAGED_DEVICE这个ACTION if (!isIntentActionValid(intent.getAction())) { ProvisionLogger.loge( ACTION_PROVISION_MANAGED_DEVICE + \u0026#34; is no longer a supported intent action.\u0026#34;); mUi.abortProvisioning(); return; } // ... if (mUtils.checkAdminIntegratedFlowPreconditions(params)) { // 进入这个分支意味着不是NFC方式，也不是PROVISION_FINANCED_DEVICE这个ACTION // ACTION为PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE时会进入这个分支 if (mUtils.shouldShowOwnershipDisclaimerScreen(params)) { // 跳转到免责声明屏幕 mUi.showOwnershipDisclaimerScreen(params); } else { // 这个方法有两个跳转方向, 如果DPC应用还没被下载安装,那么跳转到等待屏幕 // 如果DPC应用已经安装, 那么会直接向其发送Intent以确定成为DO还是PO mUi.prepareAdminIntegratedFlow(params); } mViewModel.onAdminIntegratedFlowInitiated(); } else if (mUtils.isFinancedDeviceAction(params.provisioningAction)) { // ACTION为PROVISION_FINANCED_DEVICE时会进入这个分支 mUi.prepareFinancedDeviceFlow(params); } else if (params.isNfc) { // ... } else if (isProfileOwnerProvisioning()) { startManagedProfileFlow(); } else if (isDpcTriggeredManagedDeviceProvisioning(intent)) { // TODO(b/175678720): Fail provisioning if flow started by PROVISION_MANAGED_DEVICE startManagedDeviceFlow(); } } 如何使能为 Owner 由于使能为 DO 或 PO 的路径之间存在不少可以共享的代码节点（比如下载和安装 DPC 应用），因此，ManagedProvisioning将每一个独立的节点抽象为 Task，而一个逻辑链路上需要执行的 Task 以及其先后顺序由一个抽象的 Controller 来控制，这些 Controller 又由一个静态工厂来根据ProvisioningParams控制初始化。\n// ProvisioningControllerFactory.java public class ProvisioningControllerFactory { public AbstractProvisioningController createProvisioningController( Context context, ProvisioningParams params, ProvisioningControllerCallback callback) { // ACTION为PROVISION_MANAGED_DEVICE_FROM_TRUSTED_SOURCE时会进入这个分支 if (mUtils.isDeviceOwnerAction(params.provisioningAction)) { int deviceOwner = mUtils.isHeadlessSystemUserMode() ? UserHandle.USER_SYSTEM : UserHandle.myUserId(); ProvisionLogger.logi(\u0026#34;Setting device owner on user: \u0026#34; + deviceOwner); return DeviceOwnerProvisioningController.createInstance( context, params, deviceOwner, callback, mUtils); // ACTION为PROVISION_FINANCED_DEVICE时会进入这个分支 } else if (mUtils.isFinancedDeviceAction(params.provisioningAction)) { return FinancedDeviceProvisioningController.createInstance( context, params, UserHandle.myUserId(), callback); } else { return ProfileOwnerProvisioningController.createInstance( context, params, UserHandle.myUserId(), callback); } } } 对于DeviceOwnerProvisioningController来说，负责使能为 DO 的 Task 为ProvisionFullyManagedDeviceTask：\npublic class ProvisionFullyManagedDeviceTask extends AbstractProvisioningTask { // ... @Override public void run(@UserIdInt int userId) { startTaskTimer(); FullyManagedDeviceProvisioningParams params; try { params = buildManagedDeviceProvisioningParams(userId); } catch (IllegalProvisioningArgumentException e) { ProvisionLogger.loge(\u0026#34;Failure provisioning managed device, failed to \u0026#34; + \u0026#34;infer the device admin component name\u0026#34;, e); error(/* resultCode= */ 0); return; } try { // mDpm是DevicePolicyManager mDpm.provisionFullyManagedDevice(params); } catch (Exception e) { // Catching all Exceptions to allow Managed Provisioning to handle any failure // during provisioning properly and perform any necessary cleanup. ProvisionLogger.loge(\u0026#34;Failure provisioning device owner\u0026#34;, e); error(/* resultCode= */ 0); return; } // ... } private FullyManagedDeviceProvisioningParams buildManagedDeviceProvisioningParams( @UserIdInt int userId) throws IllegalProvisioningArgumentException { ComponentName adminComponent = mProvisioningParams.inferDeviceAdminComponentName( mUtils, mContext, userId); return new FullyManagedDeviceProvisioningParams.Builder( adminComponent, mContext.getResources().getString( R.string.default_owned_device_username)) .setLeaveAllSystemAppsEnabled( mProvisioningParams.leaveAllSystemAppsEnabled) .setTimeZone(mProvisioningParams.timeZone) .setLocalTime(mProvisioningParams.localTime) .setLocale(mProvisioningParams.locale) // The device owner can grant sensors permissions if it has not opted // out of controlling them. .setDeviceOwnerCanGrantSensorsPermissions( !mProvisioningParams.deviceOwnerPermissionGrantOptOut) .build(); } // ... } 对于FinancedDeviceProvisioningController，负责使能为 DO 的 Task 为SetDeviceOwnerPolicyTask：\npublic class SetDeviceOwnerPolicyTask extends AbstractProvisioningTask { // ... @Override public void run(int userId) { boolean success; try { // 取出需要成为DO的组件名，一般来自我们Intent传入的参数， // 如果只传了包名但不明确是哪个组件, 那么这个函数会尝试找一个合适的组件 ComponentName adminComponent = mProvisioningParams.inferDeviceAdminComponentName(mUtils, mContext, userId); String adminPackage = adminComponent.getPackageName(); // 确保DPC应用已经被启用 enableDevicePolicyApp(adminPackage); // 先将相应组件注册为ActiveAdmin setActiveAdmin(adminComponent, userId); // 将DPC注册为DO success = setDeviceOwner(adminComponent, mContext.getResources().getString(R.string.default_owned_device_username), userId); // 如果ACTION的类型和分期付款相关，会修改DeviceOwner的类型 if (success \u0026amp;\u0026amp; mUtils.isFinancedDeviceAction(mProvisioningParams.provisioningAction)) { mDevicePolicyManager.setDeviceOwnerType(adminComponent, DEVICE_OWNER_TYPE_FINANCED); } } catch (Exception e) { ProvisionLogger.loge(\u0026#34;Failure setting device owner\u0026#34;, e); error(0); return; } // ... } private boolean setDeviceOwner(ComponentName component, String owner, int userId) { ProvisionLogger.logd(\u0026#34;Setting \u0026#34; + component + \u0026#34; as device owner of user \u0026#34; + userId); if (!component.equals(mUtils.getCurrentDeviceOwnerComponentName( mDevicePolicyManager))) { // 关键函数 return mDevicePolicyManager.setDeviceOwner(component, owner, userId); } return true; } // ... } ","permalink":"https://usagisang.github.io/posts/android%E4%B8%8A%E7%9A%84%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://source.android.com/docs/devices/admin\"\u003ehttps://source.android.com/docs/devices/admin\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developer.android.com/work/guide\"\u003ehttps://developer.android.com/work/guide\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://developers.google.com/android/work/play/emm-api/prov-devices\"\u003ehttps://developers.google.com/android/work/play/emm-api/prov-devices\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e本文提到的“设备管理”并不面向终端用户，而是一种支持企业管理、监控和保护所有用于工作的移动设备的实际需要而产生的一系列框架。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e关键术语\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDevice Policy Controller：设备政策控制器，简称 DPC\u003c/li\u003e\n\u003cli\u003eDevice Owner：设备所有者，是 Android 设备管理框架运行的一种模式，有时简称为 DO\u003c/li\u003e\n\u003cli\u003eProfile Owner：工作配置所有者，是 Android 设备管理框架运行的一种模式，有时简称为 PO\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"设备管理方案\"\u003e设备管理方案\u003c/h2\u003e\n\u003cp\u003e一套完整的设备管理方案通常包含了两个方面的支持。其一是安装在设备端的设备政策控制器（Device Policy Controller）应用，其二是云端的控制台。企业客户在设备上安装 DPC 应用并与云端关联注册后，可以通过云端将设备管理政策下发至 DPC 应用，DPC 应用最终执行之。\u003c/p\u003e","title":"Android上的设备管理"},{"content":" 本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\n开机动画文件路径 系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\n/apex/com.android.bootanimation/etc/bootanimation.zip (since Android 10) /product/media/bootanimation.zip (since Android 9) /oem/media/bootanimation.zip /system/media/bootanimation-encrypted.zip (if getprop(\u0026#34;vold.decrypt\u0026#34;) = \u0026#39;1\u0026#39;) /system/media/bootanimation.zip 注释1：搜索 /product 分区的特性在 Android 9 被添加，搜索/apex 分区的特性在 Android 10 才被添加，按照历史惯性而言，厂商默认的开机动画一般保存在/system分区。\n注释2：vold.decrypt属性表明此 Android 系统开启了全盘加密。全盘加密特性从 Android 10 开始已被废弃，只有在启用此特性的机器上才需要特别关注bootanimation-encrypted.zip文件。\n文件结构 bootanimation.zip一般包含以下文件：\ndesc.txt - 描述如何执行动画的文本文档 part0 \\ part1 \\ 文件夹，包含一段动画所有的帧，这些帧以PNG文件保存 ... / partN / bootanimation.zip允许定义多个不同的动画片段，并把它们串联在一起组成完整的开机动画，这些动画片段存储在不同的partN文件夹里，其中 N 指的是序号的数字。\npartN文件夹里除了包含一帧帧 PNG 图片，还可以包含一些其他资源或配置文件。\ndesc.txt 第一行定义动画的通用参数\nWIDTH HEIGHT FPS [PROGRESS] WIDTH: 动画宽度（像素） HEIGHT: 动画高度（像素） FPS: 每秒帧数，例如60 PROGRESS：（可选，since Android 12），是否显示最后一个动画片段的进度百分比 百分比将水平居中，y 坐标将被设置为动画高度的1/3。 第二行以及以后的若干行定义一个动画片段：\nTYPE COUNT PAUSE PATH [#RGBHEX [CLOCK1 [CLOCK2]]] TYPE: 单个字符，或$SYSTEM，指示动画片段的类型： p: 播放这段动画，但会被开机完成事件打断 c: 完整播放这段动画，即使开机完成, 动画也不会被打断 $SYSTEM: 加载 /system/media/bootanimation.zip 并播放它。 COUNT: 最大播放多少次动画，如果设置为 0，则动画无限循环直到启动完成 PAUSE: 该部分结束后延迟多少帧再播放下一个动画片段 PATH: 动画资源目录（例如part0） RGBHEX: （可选）背景颜色，格式为#RRGGBB CLOCK1、CLOCK2：（可选）绘制当前时间的坐标（对于手表）： 如果仅提供CLOCK1，则它会被解析为时钟的 y 坐标，时钟的 x 坐标默认为c （since Android 9）如果同时提供了CLOCK1和CLOCK2，则第一个作为 x 坐标，第二个作为 y 坐标 值可以是正整数、负整数或c c：将文本居中 正整数n，：x 坐标，从屏幕左边缘开始算起的像素，y 坐标，从屏幕下边缘开始算起的像素 -n：x 坐标，从屏幕右边缘开始算起的像素，y 坐标，从屏幕上边缘开始算起的像素 例子： -24或者c -24，将文本定位在距屏幕顶部 24 像素处，水平居中 16 c，将文本定位在距屏幕左侧 16 像素处，垂直居中 -32 32，将文本定位在屏幕右侧 32 像素、底边缘上方 32 像素处 注意，同时指定时钟的 x、y 坐标是从 Android 9.0 开始支持的特性，Android 9.0 以前只支持指定 y 坐标\nclock_font.png(since Android 9) 可以使用该文件指定绘制时间使用的字体。字体文件格式要求如下：\n该文件指定 ASCII 字符 32-127 (0x20-0x7F) 的字形，包括常规粗细和粗体粗细。 图像被划分为字符网格 有16列和6行 每行分为两半部分：上半部分为常规粗细字形，下半部分为粗体字形。 对于 NxM 大小的图像，每个字符字形的宽度为 N/16 像素，高度为 M/(12*2) 像素 加载和播放动画帧 每部分的动画都直接从 zip 文件中扫描并加载。在partN目录下，每个文件（除了trim.txt和audio.wav，请参阅下一节）都应该是一个 PNG 文件，表示该动画中的一帧（以指定的分辨率）。因此，必须按顺序命名动画帧（比如part000.png、part001.png）并按该顺序添加到 zip 文件中。\ntrim.txt 可以对动画帧进行缩放，只需要在partN目录下提供trim.txt 文件即可。这个文件按顺序列出其目录中每个帧的缩放输出，因此可以将动画帧放在合适的位置上。输出应采用以下形式：WxH+X+Y，其中W和H表示重新放大或缩小后的动画帧大小。例如：\n713x165+388+914 708x152+388+912 707x139+388+911 649x92+388+910 如果不提供该文件，则假定每个帧的大小与desc.txt中指定的宽高参数相同。\naudio.wav 每个动画片段可以选择在开始时播放wav。要启用此功能，请在partN目录下提供audio.wav文件。\n退出开机动画 系统完成启动后将结束开机动画（仍会播放任何没播完甚至还没开始播放的类型为c的开机动画），这是通过将系统属性service.bootanim.exit设置为非零字符串来完成的。\n提示 PNG压缩 可以使用zopflipng或pngcrush来压缩 PNG 图像。例如：\nfor fn in *.png ; do zopflipng -m ${fn}s ${fn}s.new \u0026amp;\u0026amp; mv -f ${fn}s.new ${fn} # or: pngcrush -q .... done 如果允许将动画减小到256种颜色，压缩效果会更好，酌情使用：\npngquant --force --ext .png *.png # alternatively: mogrify -colors 256 anim-tmp/*/*.png 如何创建 ZIP cd \u0026lt;path-to-pieces\u0026gt; zip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part* 请注意，ZIP 文件的压缩等级为0，实际上并未压缩！（使用其他压缩等级会导致读取文件失败） 因为 PNG 文件已经尽可能压缩，文件之间不太可能有任何冗余。\n开机动画与动态颜色(since Android 12L) 从 Android 12L 开始，Google 团队将 Android 12 引入的Dynamic color特性也应用到了开机动画上。在此模式下，开机动画不再直接渲染 PNG 图像，而是将 PNG 图像的 R、G、B、A 通道视为动态颜色的 mask（掩码），根据动画的进度，在开始颜色和结束颜色之间进行插值。\n要启用动态颜色特性，需要在 desc.txt 的第二行添加以下文本：\ndynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4 PATH： 要应用动态颜色过渡的部分的文件路径。该片段之前的任何部分都将以起始颜色渲染。之后的任何部分都将以最终颜色渲染。 RGBHEX1： 第一个起始颜色（masked by the R channel），指定为#RRGGBB。 RGBHEX2： 第二个起始颜色（masked by the G channel），指定为#RRGGBB。 RGBHEX3： 第三个起始颜色（masked by the B channel），指定为#RRGGBB。 RGBHEX4： 第四个起始颜色（masked by the A channel），指定为#RRGGBB。 将从以下系统属性中读取结束颜色：\npersist.bootanim.color1 persist.bootanim.color2 persist.bootanim.color3 persist.bootanim.color4 如果上面的某个系统属性为空，相应的结束颜色将默认为开始颜色，这样不会产生颜色转换。\n准备您的PNG图像，使 R、G、B、A 通道分别指示要绘制color1、color2、color3和color4的区域。\n动态颜色与开机动画的关系 简单来说，动态颜色是根据用户的相关设置（比如壁纸）等动态生成主题颜色调色板，并应用到系统上的过程。主题色变更后，系统将其更新在系统属性persist.bootanim.color1到persist.bootanim.color4上，也就是上文所说的结束颜色，开机动画通过读取系统属性并应用到动画上以支持动态颜色。\n但经过上文的分析，我们也都清楚开机动画实际由一张张 PNG 图片组成的，图片上的颜色肯定是固定的，那么如何做到动态着色呢？\n其实，图像本质上是保存“坐标”到“颜色”的映射的二维数组，想要支持动态颜色，我们需要给出“图像上的颜色”到“系统的动态颜色”的映射，那么解决方式就很简单了：\n首先，我们从动画中提炼几种主要出现的固定颜色并把它们映射到动态颜色上，对比上面的描述，这一步相当于在desc.txt中填写dynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4，每一个被填上去的固定颜色会被映射到相应的系统属性。\n接下来，原来的动画帧中不应再保存固定颜色，而是保存这些颜色的“索引”，比如说我们简单用1、2、3、4来索引四种固定颜色，0表示没有任何颜色，那么，一个3x3的图像看起来可能像这样：\n[0, 0, 0], [0, 1, 2], [0, 4, 3] 这种索引方式没有任何问题，只是稍显笨拙。除了简单的索引值，我们还可以考虑混合四种固定颜色的情况，即用四维向量来表示一个位置上的颜色，向量的分量表示混合了多少对应的固定颜色，这类似于我们用 RGB 来表示颜色，只不过现在三原色变成了“四原色”（姑且不考虑这四种颜色能不能组成正交基）。我们如何保存向量的分量值呢？原来的 PNG 图像在这时就派上了用场，PNG 图像有 ARGB 四个颜色通道，正好对应向量的四个分量！\n如果有助于你理解的话，你还可以认为我们将图像的标准正交基从纯色变换为其他颜色\nBootAnimation.cpp 中的 glsl 代码如下：\nprecision mediump float; const float cWhiteMaskThreshold = 0.05; uniform sampler2D uTexture; uniform float uFade; uniform float uColorProgress; uniform vec3 uStartColor0; uniform vec3 uStartColor1; uniform vec3 uStartColor2; uniform vec3 uStartColor3; uniform vec3 uEndColor0; uniform vec3 uEndColor1; uniform vec3 uEndColor2; uniform vec3 uEndColor3; varying highp vec2 vUv; void main() { vec4 mask = texture2D(uTexture, vUv); float r = mask.r; float g = mask.g; float b = mask.b; float a = mask.a; // If all channels have values, render pixel as a shade of white. float useWhiteMask = step(cWhiteMaskThreshold, r) * step(cWhiteMaskThreshold, g) * step(cWhiteMaskThreshold, b) * step(cWhiteMaskThreshold, a); // 图像的rgba现在变为了动态颜色的系数, 这意味着它们共同指导了某个像素应当混合哪几类基色，并且每种基色混合到什么程度 vec3 color = r * mix(uStartColor0, uEndColor0, uColorProgress) + g * mix(uStartColor1, uEndColor1, uColorProgress) + b * mix(uStartColor2, uEndColor2, uColorProgress) + a * mix(uStartColor3, uEndColor3, uColorProgress); // 如果图像的rgba都有值，那么将会求rgba的平均值, 并将这个平均值作为颜色的三个分量，也就是说颜色变成灰色或白色 color = mix(color, vec3((r + g + b + a) * 0.25), useWhiteMask); gl_FragColor = vec4(color.x, color.y, color.z, (1.0 - uFade)); } 调试技巧 如果希望在运行中的系统调试开机动画，请顺序执行以下命令：\nadb root adb remount // 覆盖系统中原本的开机动画，push命令的路径应根据实际情况修改 adb push .\\bootanimation.zip /system/media/bootanimation.zip // 这个属性标记了开机动画是否应当退出, 重置这个标志以保证开机动画会被执行(即使类型为p) adb shell setprop service.bootanim.exit 0 adb shell setprop ctl.start bootanim 如果开机动画被配置为无限循环，再次执行以下命令（重新置位）才能终止开机动画：\nadb shell setprop service.bootanim.exit 1 ","permalink":"https://usagisang.github.io/posts/android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"开机动画文件路径\"\u003e开机动画文件路径\u003c/h2\u003e\n\u003cp\u003e系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\u003c/p\u003e","title":"Android开机动画修改指南"},{"content":"什么是 Memory 在通俗意义上来，Memory 一般翻译为存储器，存储器用来指代那些能够帮助计算机存储信息的部件。由于目前还不存在速度快、数据断电不丢失同时单位容量价格又低的存储器技术，为了平衡 I/O 性能和价格，取舍之间，计算机通常会构建一个包含三层的存储器层次结构，即 CPU Cache、主存、外存（硬盘）\n我们可以用 Cache、主存储器（Main Memory）、外存储器（External Storage）来加以区分这三层存储器。但在日常谈话中也经常使用“内存”或者“运行内存”（移动设备居多）来指代 Main Memory，使用“硬盘”来指代 External Storage。\nMemory 的分类 可以从三个角度来对存储器进行分类：\n顺序存取/随机存取\n顺序存取存储器（Serial Access Memory）的典型代表就是磁带。随机存取存储器（Random Access Memory）或者被经常提到的另一个简称——RAM，是目前存储器技术的中流砥柱。存储器是否能支持随机存取通常由它的物理结构所决定。事实上，所有的半导体存储器都支持随机访问。\n只读/可读可写\n只读存储器（Read Only Memory）简称 ROM。ROM主要用于存储计算机中很少会再次更改的软件，比如引导操作系统加载的程序。现在制造的所有 ROM 都是非易失性的，因为显而易见，易失性的 ROM 实用价值很低。\n⚠️实际上，现在 RAM 成为了可读可写的存储器的通用称呼，所谓的“RAM”已经脱离了“随机存取”的含义，成为了 ROM 的反义词。我们接下来所提到的 RAM 指代的都是这一层含义。\n易失性/非易失性\n”易失性/非易失性“主要指的是存储器的数据在断电后是否能够继续保持。通常我们把非易失性存储器称作 NVM （Non-Volatile Memory），但由于 ROM 都是非易失性的，因此”易失性/非易失性“主要用于区分 RAM。非易失性随机存储器（Non-Volatile RAM）简称 NVRAM；易失性随机存储器主要分为两类：动态随机存储器（Dynamic RAM）和静态随机存储器（Static RAM），它们又分别简称为 DRAM 和 SRAM。由于目前 NVRAM 应用还不是很广泛，因此提到 RAM 时，我们通常都认为其是易失性的，而需要专门提到非易失性存储器时才会搬出 NVRAM 这个名称。\n接下来我们将对上面提到的术语做补充说明。\nDRAM and SRAM DRAM 与 SRAM 的区别体现在了名字上：由于 DRAM 需要周期性地给电容补充电荷以避免数据丢失，因此被称为 dynamic；SRAM 只要通上电就能保持数据存储，不需要刷新，因此被称为 static。\n总体上看，DRAM 既耗电，存取速度也慢，但是胜在结构简单，制造成本低，与之相对 SRAM 的制造成本偏高。所以，在需要量大管饱的主存储器层级，几乎都会选用 DRAM 方案，而因为主存储器过慢而衍生的 CPU Cache 层级一般都采用 SRAM 方案。\n关于 DRAM 技术的发展，可以参考从零学习DRAM\n提到主存储器，另一个不得不提的术语是“DDR”。从原始定义上讲，DDR 指的是双倍数据速率（Double Data Rate），它指的是在时钟的上升沿和下降沿都进行数据传输，从而使得数据带宽提高了一倍的一种手段。目前主流的主存储器都使用了 DDR，所以，我们也经常使用 DDR 来指代一个稍微有点长的名词：DDR SDRAM。（SDRAM 指的是以同步方式进行工作的 DRAM）\n另外，我们之前提到过DRAM过于耗电的缺陷，这对于台式机来说尚且可以接受，但是对于带电池的移动设备、嵌入式设备、笔记本等电子产品来说，续航要求严格，因此又催生了 LPDDR SDRAM（一般简称为 LPDDR），即 Low-Power（低功耗） 的 DDR SDRAM。LPDDR 虽然牺牲了性能，但更加省电。\nROM 的发展 在集成电路出现之前，ROM 以各种形式出现过，比如说上世纪登月计划就用磁芯绳编制成一块存储器，用来当 ROM。随着集成电路的诞生，出现了用光刻的方式进行制造的 ROM，因为光刻时需要用到掩膜（Mask），因此这种类型的 ROM 被称为 MaskROM。MaskROM 的物理特性决定了它在刻录完成后，就不可能再修改，是名副其实的 read only memory，但正因如此，MaskROM 有着许多缺点：第一，制造一块掩膜的成本很高（可以理解为工厂开模具），这导致如果需要生产的 MaskROM 太少的话就非常划不来。第二，软件研发常常需要快速更改设计的内容并验证，而 MaskROM 的生产过程导致根本无法满足这一点。\n随后出现的其他类型的 ROM 都在设法提高灵活性。1956 年被发明的可编程 ROM（Programmable ROM，简称 PROM）允许用户更改一次内部的存储内容，然后不可再更改（只能进行一次软件烧录）。\n接下来，ROM 以一种稍显矛盾的方式发展了下去。要想继续提高 ROM 的灵活性，无非就是允许 ROM 进行多次的烧录，于是在1971年，一项新的技术出现了——EPROM，一种可擦除可编程的 ROM。EPROM 中的 \u0026ldquo;E\u0026rdquo; 指的是 erasable。话说回来，可以擦除掉内容并且再次烧录的 ROM，应该叫做 read only memory 吗？不管如何，ROM 这个名字延续了下来，只是我们要特别注意的是，提到 ROM 这个词不再代表 ROM 一定是 read only 的。EPROM 被编程之后，可以通过暴露在强紫外线光源（例如汞蒸气灯）的方式进行擦除。不过，EPROM诞生不久就很快有了更便捷的代替品，1972年，电可擦除可编程 ROM（Electrically erasable Programmable ROM，简称 EEPROM）诞生了。当然了，当时的 EEPROM 技术还远远未到成熟阶段，每块芯片的价格依然大幅高于批量生产的 MaskROM，直到2000年左右，可重编程 ROM 成本下降才几乎消除了 MaskROM 的市场。\n诞生于20世纪80年代闪存（Flash Memory）技术属于 EEPROM 的一种，它相当程度上影响了我们现在的存储方式。得名\u0026quot;Flash\u0026quot;是因为相比起当时的其他 EEPROM 技术来说，Flash Memory 的速度较快，而且可以只对存储的特定部分进行擦除和编程，而不必全盘擦除。\nFlash Memory 主要有两种技术分支，分别称作 NOR Flash 和 NAND Flash。我们更熟悉的 NAND 技术每 GB 成本更便宜，因此通常用来制作大容量的存储器，比如说固态硬盘（SSD）或者嵌入式多媒体卡（embedded Multi Media Card，或者简称 eMMC）。\n","permalink":"https://usagisang.github.io/posts/%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD%E7%AE%80%E6%9E%90/","summary":"\u003ch2 id=\"什么是-memory\"\u003e什么是 Memory\u003c/h2\u003e\n\u003cp\u003e在通俗意义上来，Memory 一般翻译为存储器，存储器用来指代那些能够帮助计算机存储信息的部件。由于目前还不存在速度快、数据断电不丢失同时单位容量价格又低的存储器技术，为了平衡 I/O 性能和价格，取舍之间，计算机通常会构建一个包含三层的存储器层次结构，即 CPU Cache、主存、外存（硬盘）\u003c/p\u003e","title":"存储技术常用术语简析"},{"content":"关于三维空间中的旋转，我们以前提到过基于欧拉角的旋转表达矩阵，它们分别描述了围绕 x 轴、y 轴、z 轴旋转后坐标应当如何变化。事实上，我们可以更进一步，推导出一个通用的、围绕过原点的任意轴旋转的公式。\n题设 这一节我们来描述我们已知的条件和待求的目标：\n给定一个方向向量$\\vec{u}$作为旋转轴，$\\vec{v}$为待旋转的向量，我们希望得到$\\vec{v}$围绕着$\\vec{u}$逆时针旋转$\\theta$角度之后的向量$\\vec{v'}$。注意，$\\vec{v'}$的表达式必须用已知条件$\\vec{u}$、$\\vec{v}$和$\\theta$来表达。\n思路 旋转前后向量的长度不会变化，反而是如何计算旋转后向量的方向成为了一个难题。我们采用分解向量的思路来解决向量旋转的问题——把$\\vec{v}$分解为平行于$\\vec{u}$的向量$\\vec{v_{//}}$和垂直于$\\vec{u}$的向量$\\vec{v_\\bot}$，分解的示意图如下：\n这样定义向量的分解方式是有好处的，我们可以发现，旋转前后$\\vec{v_{//}}$没有变化，而旋转前的$\\vec{v_\\bot}$、旋转后的$\\vec{v'_\\bot}$都在一个平面内，同一个平面内的旋转比起三维旋转要好解决的多。\n公式推导 $\\vec{v_{//}}$实际上是$\\vec{v}$在$\\vec{u}$上的正交投影，因此我们可以得出： $$ \\begin{align} \\vec{v_{//}}\u0026=|\\vec{v}|\\frac{\\vec{u}\\cdot\\vec{v}}{|\\vec{u}|\\cdot|\\vec{v}|}\\cdot\\frac{\\vec{u}}{|\\vec{u}|}\\\\ \u0026=\\frac{\\vec{u}\\cdot\\vec{v}}{|\\vec{u}|^2}\\vec{u}\\\\ \u0026=(\\vec{u}\\cdot{\\vec{v}})\\vec{u} \\end{align} $$ 然后，我们运用向量减法给出$\\vec{v_{\\bot}}$的表达式： $$ \\vec{v_{\\bot}}=\\vec{v}-\\vec{v_{//}} $$ 接下来，我们需要给出$\\vec{v\u0026rsquo;_\\bot}$的表达式。给出一个直观的旋转俯视图：\n先定义$\\vec{w}$。引入这个向量是为了正交分解$\\vec{v'_\\bot}$，因此它必须垂直于$\\vec{v_{\\bot}}$。如果你对叉乘很熟悉的话，很快就能想到我们可以用$\\vec{u}\\times\\vec{v}$来得到具有这样的性质的向量。注意叉乘的顺序，根据旋转示意图和右手定则，$\\vec{u}\\times\\vec{v_{\\bot}}$的向量方向才是俯视图中的$\\vec{w}$方向。\n然后，我们把$\\vec{v'_\\bot}$正交分解成平行于$\\vec{v_{\\bot}}$的$\\vec{v'_{v}}$和平行于$\\vec{w}$的$\\vec{v'_w}$，并给出$\\vec{v'_\\bot}$的表达式。 $$ \\displaylines{ \\vec{v'_\\bot}=\\vec{v'_{v}}+\\vec{v'_w}\\\\ \\vec{v'_{v}}=|\\vec{v_\\bot}|\\cos\\theta\\cdot\\frac{\\vec{v_\\bot}}{|\\vec{v_\\bot}|}=\\vec{v_\\bot}\\cos\\theta\\\\ \\vec{v'_w}=|\\vec{v_\\bot}|\\sin\\theta\\cdot\\frac{\\vec{u}\\times\\vec{v_{\\bot}}}{|\\vec{u}\\times\\vec{v_{\\bot}}|}\\\\ |\\vec{u}\\times\\vec{v_{\\bot}}|=|\\vec{u}||\\vec{v_{\\bot}}|\\sin(\\pi/2)=|\\vec{v_{\\bot}}|\\\\ \\vec{v'_w}=(\\vec{u}\\times\\vec{v_{\\bot}})\\sin\\theta\\\\ \\vec{v'_\\bot}=\\vec{v_\\bot}\\cos\\theta+(\\vec{u}\\times\\vec{v_{\\bot}})\\sin\\theta } $$ 上面的式子可以进一步被化简，我们代入$\\vec{v_{\\bot}}$的表达式，并运用叉乘的分配律： $$ \\displaylines{ \\vec{v'_\\bot}=(\\vec{v}-\\vec{v_{//}})\\cos\\theta+(\\vec{u}\\times(\\vec{v}-\\vec{v_{//}}))\\sin\\theta\\\\ 使用分配律，(\\vec{u}\\times(\\vec{v}-\\vec{v_{//}}))=\\vec{u}\\times\\vec{v}-\\vec{u}\\times\\vec{v_{//}}\\\\ 因为共线，\\vec{u}\\times\\vec{v_{//}}=0\\\\ \\vec{v'_\\bot}=\\vec{v}\\cos\\theta-\\vec{v_{//}}\\cos\\theta+(\\vec{u}\\times\\vec{v})\\sin\\theta } $$ 最后，我们终于可以给出$\\vec{v\u0026rsquo;}$的表达式： $$ \\begin{aligned} \\vec{v'}\u0026=\\vec{v_{//}}+\\vec{v'_{\\bot}}\\\\ \u0026=\\vec{v_{//}}+\\vec{v}\\cos\\theta-\\vec{v_{//}}\\cos\\theta+(\\vec{u}\\times\\vec{v})\\sin\\theta\\\\ \u0026=\\vec{v}\\cos\\theta+(1-\\cos\\theta)\\vec{v_{//}}+(\\vec{u}\\times\\vec{v})\\sin\\theta\\\\ \u0026=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\end{aligned} $$ 因此： $$ \\vec{v'}=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\tag{1} $$ 公式（1）即为标题中的 Rodrigues’ Rotation Formula。\n化简为矩阵 我们需要进一步化简公式，得到其等价的矩阵表达形式，才方便代码的实现。\n首先，我们需要知道向量三重积公式： $$ \\vec{a}\\times(\\vec{b}\\times\\vec{c})=(\\vec{a}\\cdot\\vec{c})\\cdot\\vec{b}-(\\vec{a}\\cdot\\vec{b})\\cdot\\vec{c} \\tag{2} $$ 然后，我们还需要知道，向量的叉乘与矩阵之间的联系： $$ \\vec{a}\\times\\vec{b}=\\begin{pmatrix}y_az_b-z_ay_b\\\\z_ax_b-x_az_b\\\\x_ay_b-y_ax_b\\end{pmatrix}=A\\cdot b= \\begin{pmatrix} 0 \u0026 -z_a \u0026 y_a\\\\ z_a\u0026 0 \u0026 -x_a\\\\ -y_a\u0026 x_a \u0026 0 \\end{pmatrix}\\begin{pmatrix}x_b\\\\y_b\\\\z_b\\end{pmatrix} \\tag{3} $$ 向量的叉乘可以化为矩阵与向量的乘积，而且需要注意的是，矩阵只与左边的向量有关。\n我们化简的目标是得到下述形式的表达式，其中M是矩阵。 $$ \\vec{v'}=M\\cdot\\vec{v} $$ 再次观察公式（1）： $$ \\vec{v'}=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\tag{1} $$ 对于第一项和第三项来说，它们都可以快速化为等价的矩阵形式，其中，$\\vec{v}\\cos\\theta$可以化为： $$ \\vec{v}\\cos\\theta=\\begin{pmatrix} \\cos\\theta \u0026 0 \u0026 0\\\\ 0 \u0026 \\cos\\theta \u0026 0\\\\ 0 \u0026 0 \u0026 \\cos\\theta \\end{pmatrix}\\cdot\\vec{v} $$ 正如前文所说，$(\\vec{u}\\times\\vec{v})\\sin\\theta$可以利用公式（3）将叉乘化成矩阵乘向量的形式，这里记向量$\\vec{u}$形成的矩阵为$R_u$，可以得到： $$ (\\vec{u}\\times\\vec{v})\\sin\\theta=R_u\\sin\\theta\\cdot\\vec{v} \\tag{4} $$ 比较难以化简的是第二项，处于外部的是向量$\\vec{u}$而不是$\\vec{v}$，这给我们带来了一些麻烦。观察$(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$这一项和已知的三重积公式（2），或许可以想办法配凑另外一项，从而把点乘变为叉乘，再运用叉乘的性质化作矩阵。有好几种可能的叉乘式，最终我们选择配凑出这样的叉乘：$\\vec{u}\\times(\\vec{u}\\times\\vec{v})$。其中一个理由是$\\vec{u}$都在左边，我们可以复用前面提到的矩阵$R_u$；另一个理由是缺失的那一项很好配凑： $$ \\vec{u}\\times(\\vec{u}\\times\\vec{v})=(\\vec{u}\\cdot\\vec{v})\\vec{u}-(\\vec{u}\\cdot\\vec{u})\\vec{v}=(\\vec{u}\\cdot\\vec{v})\\vec{u}-\\vec{v} $$ 我们已经有了$(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$这一项，而且它的系数是$(1-\\cos\\theta)$，那么接下来就要配凑出$-(1-\\cos\\theta)\\vec{v}$这一项了。这很简单，我们结合公式（1）的第一项 $\\vec{v}\\cos\\theta$： $$ \\begin{aligned} \\vec{v}\\cos\\theta \u0026=\\vec{v}\\cos\\theta+\\vec{v}-\\vec{v}\\\\ \u0026=\\vec{v}-(1-\\cos\\theta)\\vec{v} \\end{aligned} $$ 因此，我们可以将公式（1）的前两项$\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$化简为： $$ \\begin{aligned} \\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u} \u0026=\\vec{v}-(1-\\cos\\theta)\\vec{v}+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}\\\\ \u0026=\\vec{v}+(1-\\cos\\theta)((\\vec{u}\\cdot{\\vec{v}})\\vec{u}-\\vec{v})\\\\ \u0026=\\vec{v}+(1-\\cos\\theta)(\\vec{u}\\times(\\vec{u}\\times\\vec{v})) \\end{aligned} $$ 最终我们如愿以偿得到了两重叉乘：$\\vec{u}\\times(\\vec{u}\\times\\vec{v})$。不过，两重叉乘也可以运用公式（3）吗？当然可以，运用两遍即可。而且，由于矩阵内的所有参数只和叉乘式的左边有关，因此我们会得到两个相同的矩阵： $$ \\begin{aligned} \\vec{u}\\times(\\vec{u}\\times\\vec{v}) \u0026=\\vec{u}\\times(R_u\\cdot\\vec{v})\\\\ \u0026=R_u\\cdot (R_u\\cdot\\vec{v})\\\\ \u0026=R_u^2\\cdot\\vec{v} \\end{aligned} $$ 我们得以将公式（1）的前两项化作矩阵向量乘法： $$ \\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}=\\vec{v}+(1-\\cos\\theta)\\cdot R_u^2\\cdot\\vec{v} \\tag{5} $$ 最后，结合（4）与（5），我们将公式（1）化简为： $$ \\displaylines{ \\vec{v'}=\\vec{v}+(1-\\cos\\theta)\\cdot R_u^2\\cdot\\vec{v}+R_u\\sin\\theta\\cdot\\vec{v}\\\\ 记I为单位矩阵，则\\\\ \\vec{v'}=(I+(1-\\cos\\theta)\\cdot R_u^2+R_u\\sin\\theta)\\cdot\\vec{v}\\\\ } $$ 矩阵 $$ M=I+(1-\\cos\\theta)\\cdot R_u^2+R_u\\sin\\theta \\tag{6} $$ 即为我们所求的矩阵。\nRefer 罗德里格旋转公式（Rodrigues\u0026rsquo; rotation formula）\n四元数与三维旋转\n","permalink":"https://usagisang.github.io/posts/rodrigues-rotation-formula/","summary":"\u003cp\u003e关于三维空间中的旋转，我们以前提到过基于欧拉角的旋转表达矩阵，它们分别描述了围绕 x 轴、y 轴、z 轴旋转后坐标应当如何变化。事实上，我们可以更进一步，推导出一个通用的、围绕过原点的任意轴旋转的公式。\u003c/p\u003e","title":"Rodrigues’ Rotation Formula"},{"content":" 本文是源码分析类文章\n如何为Compose Image提供网络图片加载支持？目前（Compose 1.0.5）最好的选择似乎是使用图片框架Coil，Coil对Jetpack Compose相关的支持文档在这。\nCompose内的Image组件类似于ImageView，仅支持从本地加载图片资源，要想从网络中获取图片并加载，我们首先就得要使用能够处理网络请求的框架，将远程图片资源载入到本地才行。目前主流的图片加载框架Picasso、Glide、Coil等，它们更多面对的仍是传统的View系统下，将图片加载到ImageView中并显示这样的应用场景，而不是为Compose量身打造的，基于此，Accompanist库曾提供了一些图片加载框架的扩展库，为Compose的Image显示网络图片进行简便支持。时过境迁，后来Coil为Image加载图片提供了相关支持，故Accompanist以前关于图片加载框架扩展的依赖都被废弃并不推荐使用了。（Picasso可能在长期内都不会支持Compose Image，详情）\n接下来我们将分析Accompanist曾经是如何对图片框架做扩展适配，使之能够与Compose配合工作的。\nPicasso(in version 0.6.2) Accompanist在0.3.0版本就提供了Picasso的支持，不过，在版本0.7.0该集成被移除（相关的pull参见https://github.com/google/accompanist/pull/253）\n在0.6.2版本中，想要加载网络图片，你可能会使用如下代码：\nPicassoImage( data = \u0026#34;http://...\u0026#34; modifier = Modifier.size(50.dp), ) { imageLoadState -\u0026gt; when(imageLoadState) { ... } } CoilImage( data = \u0026#34;https://i.imgur.com/StXm8nf.jpg\u0026#34;, contentDescription = null, onRequestCompleted = { println(\u0026#34;LoadingCoilImage onRequestCompleted $it\u0026#34;) }, contentScale = ContentScale.Crop, modifier = Modifier.fillMaxWidth(), ) { ... } 在version 0.6.2中，加载远程图片的方法是使用专用的Image组件，使用Picasso框架的调用PicassoImage，使用Coil的则调用CoilImage，等等。它们都依赖于一个imageloader-core的核心库来进行图片加载，我们不难想象这个加载图片的方法，为了糅合各类框架，肯定要用不少泛型，事实上它长下面这样：\n@Composable fun \u0026lt;R : Any, TR : Any\u0026gt; ImageLoad( request: R, executeRequest: suspend (TR) -\u0026gt; ImageLoadState, modifier: Modifier = Modifier, requestKey: Any = request, transformRequestForSize: (R, IntSize) -\u0026gt; TR?, shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -\u0026gt; Boolean = DefaultRefetchOnSizeChangeLambda, onRequestCompleted: (ImageLoadState) -\u0026gt; Unit = EmptyRequestCompleteLambda, content: @Composable BoxScope.(imageLoadState: ImageLoadState) -\u0026gt; Unit ) { ... } 泛型R代表请求的值，这个值之所以是泛型，是因为实际上各种框架都支持多类型的图片加载请求，这个请求可能是基于一个URL的String，也可能单纯是一个resource的id，或者就是一个Bitmap，等等。泛型TR代表了不同图片框架内收集本次图片请求信息的实体类（或者是Builder），在Picasso中这个类叫RequestCreator，在Glide中这个类叫RequestBuilder。\n我们继续观察它的实现：\n@Composable fun \u0026lt;R : Any, TR : Any\u0026gt; ImageLoad( request: R, executeRequest: suspend (TR) -\u0026gt; ImageLoadState, modifier: Modifier = Modifier, requestKey: Any = request, transformRequestForSize: (R, IntSize) -\u0026gt; TR?, shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -\u0026gt; Boolean = DefaultRefetchOnSizeChangeLambda, onRequestCompleted: (ImageLoadState) -\u0026gt; Unit = EmptyRequestCompleteLambda, content: @Composable BoxScope.(imageLoadState: ImageLoadState) -\u0026gt; Unit ) { // 三个rememberUpdatedState，目的是为了避免更改后重组 val updatedOnRequestCompleted by rememberUpdatedState(onRequestCompleted) val updatedTransformRequestForSize by rememberUpdatedState(transformRequestForSize) val updatedExecuteRequest by rememberUpdatedState(executeRequest) // 这个state拿来缓存控件大小，因为控件大小要等到Compose内容传入constraints才能确定 var requestSize by remember(requestKey) { mutableStateOf\u0026lt;IntSize?\u0026gt;(null) } // 重点，这里使用produceState将executeRequest返回的非Compose状态转换为一个State // 之所以连加载图片的过程都抽象成一个叫executeRequest的lambda，还是因为要糅合多个框架 val loadState by produceState\u0026lt;ImageLoadState\u0026gt;( initialValue = ImageLoadState.Loading, key1 = requestKey, key2 = requestSize, ) { // value一开始肯定被赋值为ImageLoadState.Loading，因为requestSize为空。 // 当requestSize被赋值后，首先将开始执行transformRequestForSize这个lambda // 传入原来的request和新获得的size，要求返回一个类似RequestBuilder的结果 value = requestSize?.let { updatedTransformRequestForSize(request, it) } ?.let { transformedRequest -\u0026gt; // 这里传入刚才的RequestBuilder try { // 发起图片加载请求，这里可能会挂起 updatedExecuteRequest(transformedRequest) } catch (e: CancellationException) { // We specifically don\u0026#39;t do anything for the request coroutine being // cancelled: https://github.com/google/accompanist/issues/217 // 如果我们响应了协程的CancellationException，让ImageLoadState变成了Error // 有可能会出问题，因为如果取消的协程在新协程完成后执行， // 会导致新的图片状态（Success）被上次取消的结果（Error）覆盖 throw e } catch (e: Error) { // Re-throw all Errors throw e } catch (e: IllegalStateException) { // Re-throw all IllegalStateExceptions throw e } catch (t: Throwable) { // Anything else, we wrap in a Error state instance // 除了CancellationException、Error、IllegalStateException之外， // 其余的错误将会令状态转变为Error ImageLoadState.Error(painter = null, throwable = t) // also内，加载完成，回调onRequestCompleted }.also(updatedOnRequestCompleted) } ?: ImageLoadState.Loading } BoxWithConstraints( modifier = modifier, propagateMinConstraints = true, ) { val size = IntSize( width = if (constraints.hasBoundedWidth) constraints.maxWidth else -1, height = if (constraints.hasBoundedHeight) constraints.maxHeight else -1 ) if (requestSize == null || (requestSize != size \u0026amp;\u0026amp; shouldRefetchOnSizeChange(loadState, size)) ) { requestSize = size } content(loadState) } } ImageLoad的思路清晰明了：调用方告诉它如何build一个请求，并在使用图片框架的过程中产生ImageLoadState状态，它会把ImageLoadState转换为可以观察的State\u0026lt;ImageLoadState\u0026gt;。\n直接使用通用实现的缺点在于会产生很多模板代码，可以基于通用实现进行更简洁的封装，我们以特定的PicassoImage的实现为例进行分析：\n// 这个API封装更彻底，不需要写when(state)，直接在函数中传入error、loading的内容即可 @Composable fun PicassoImage( data: Any, contentDescription: String?, modifier: Modifier = Modifier, alignment: Alignment = Alignment.Center, contentScale: ContentScale = ContentScale.Fit, colorFilter: ColorFilter? = null, fadeIn: Boolean = false, picasso: Picasso = LocalPicasso.current, requestBuilder: (RequestCreator.(size: IntSize) -\u0026gt; RequestCreator)? = null, shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -\u0026gt; Boolean = DefaultRefetchOnSizeChangeLambda, onRequestCompleted: (ImageLoadState) -\u0026gt; Unit = EmptyRequestCompleteLambda, error: @Composable (BoxScope.(ImageLoadState.Error) -\u0026gt; Unit)? = null, loading: @Composable (BoxScope.() -\u0026gt; Unit)? = null, ) { PicassoImage( data = data, modifier = modifier, requestBuilder = requestBuilder, picasso = picasso, shouldRefetchOnSizeChange = shouldRefetchOnSizeChange, onRequestCompleted = onRequestCompleted, ) { imageState -\u0026gt; when (imageState) { is ImageLoadState.Success -\u0026gt; { // MaterialLoadingImage是0.6.2版本中存在的一个实现fadeIn效果的控件 // 原理是使用Compose动画中的Transition托管三个动画 // alpha(透明度),brightness(亮度),saturation(饱和度), // 同时修改传入Image内的colorFliter的这三个值，从而实现渐入效果 MaterialLoadingImage( result = imageState, contentDescription = contentDescription, fadeInEnabled = fadeIn, alignment = alignment, contentScale = contentScale, colorFilter = colorFilter ) } is ImageLoadState.Error -\u0026gt; if (error != null) error(imageState) ImageLoadState.Loading -\u0026gt; if (loading != null) loading() ImageLoadState.Empty -\u0026gt; Unit } } } @Composable fun PicassoImage( data: Any, modifier: Modifier = Modifier, picasso: Picasso = LocalPicasso.current, requestBuilder: (RequestCreator.(size: IntSize) -\u0026gt; RequestCreator)? = null, shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -\u0026gt; Boolean = DefaultRefetchOnSizeChangeLambda, onRequestCompleted: (ImageLoadState) -\u0026gt; Unit = EmptyRequestCompleteLambda, content: @Composable BoxScope.(imageLoadState: ImageLoadState) -\u0026gt; Unit ) { ImageLoad( request = data.toRequestCreator(picasso), requestKey = data, // Picasso RequestCreator doesn\u0026#39;t support equality so we use the data executeRequest = { r -\u0026gt; @OptIn(ExperimentalCoroutinesApi::class) suspendCancellableCoroutine { cont -\u0026gt; // 初始化了一个Target，这个Target用来获取图片加载结果 val target = object : com.squareup.picasso.Target { override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) { val state = ImageLoadState.Success( painter = BitmapPainter(bitmap.asImageBitmap()), source = from.toDataSource() ) // 协程恢复 cont.resume(state) { // Not much we can do here. Ignore this } } override fun onBitmapFailed(exception: Exception, errorDrawable: Drawable?) { val state = ImageLoadState.Error( throwable = exception, painter = errorDrawable?.toPainter(), ) // 协程恢复 cont.resume(state) { // Not much we can do here. Ignore this } } override fun onPrepareLoad(placeholder: Drawable?) = Unit } cont.invokeOnCancellation { // 取消图片加载 picasso.cancelRequest(target) } // Now kick off the image load into our target r.into(target) } }, transformRequestForSize = { r, size -\u0026gt; val sizedRequest = when { // 如果尺寸包含未指定尺寸的尺寸，我们不会在Coil请求中指定尺寸 size.width \u0026lt; 0 || size.height \u0026lt; 0 -\u0026gt; r size != IntSize.Zero -\u0026gt; { r.resize(size.width, size.height) .centerInside() .onlyScaleDown() } // Otherwise we have a zero size, so no point executing a request // 未获得size，因此暂时无法生成请求 else -\u0026gt; null } // 根据参数来build请求 if (sizedRequest != null \u0026amp;\u0026amp; requestBuilder != null) { // If we have a transformed request and builder, let it run requestBuilder(sizedRequest, size) } else { // Otherwise we just return the sizedRequest sizedRequest } }, shouldRefetchOnSizeChange = shouldRefetchOnSizeChange, onRequestCompleted = onRequestCompleted, modifier = modifier, content = content ) } 现在让我们来总结一下，在0.6.2版本，实现网络图片加载的集成库思路如下：\n图片加载：使用Target回调获取加载的结果（各个框架都有类似的抽象的Target而不是限制目标必须是ImageView）。结果返回的过程是阻塞式，协程将在produceState内执行到 updatedExecuteRequest(transformedRequest)后挂起，直到这个lambda返回结果，State的值将会在结果返回后产生变化。当然，如果协程被取消，Picasso也会取消加载到Target那个图片请求。 图片大小约束：依赖于BoxWithConstraints获得的约束大小。 渐入动画实现：使用动画API Transition 对ColorFliter的alpha,brightness,saturation进行动态修改，从而实现渐入动画。 loading占位图、error显示等：依赖于用户传入的@Composable内容.根据produceState生成的状态，PicassoImage内显示的@Composable内容会动态变化。 Glide(in version 0.13.0) 0.3.0版本诞生于2020年10月份，而当时间来到了2021年4月，Accompanist发布0.8.0版本，Coil 和 Glide 集成库进行了大规模的重构。上面提到的类似于CoilImage()和GlideImage()API都已经被弃用了。\n以下对Glide集成库的分析基于版本0.13.0的代码。\n如果在0.13.0版本想要加载远程图片，或许你会写出以下的代码：\nImage( painter = rememberGlidePainter(request = \u0026#34;http://...\u0026#34;), contentDescription = null ) 新的API不再需要专门的Image组件，而是使用Painter这种概念来表现加载的结果。新的API对性能的提升似乎有所提升：Compose内容重组后，需要重绘的不再是不同的Loading组件或Success组件，现在核心组件一定是一个Image，随加载状态变化的只不过是Image内绘制的内容而已，重绘范围有所缩小。这很符合我们对ImageView的想象：在加载的时候显示一张placeholder占位图，成功显示最终结果，否则显示error图片，而placeholder和error都可以发起图片加载请求的时候设置。\nPainter是一个什么样的概念？我们可以先看一下类注释是怎么介绍它的：\n/** * 对可以画出来的东西的抽象。除了能够绘制到指定的有界区域外，Painter还提供了一些高级机制，消费者可以使用 * 这些机制来配置内容的绘制方式。其中包括alpha、ColorFilter和RTL * 实现应该提供一个有意义的equals方法来比较不同Painter子类的值，而不仅仅依赖于引用相等 */ abstract class Painter { ... protected abstract fun DrawScope.onDraw() } 描述看起来有点像Drawable，但实际上Drawable比Painter更加复杂一些，除了上述的alpha、ColorFilter、LayoutDirection之外，Drawable还具有动画Callback、Level、Hotspot等属性。DrawScope.onDraw()方法类似于Drawable的draw(Canvas canvas)。\n继续观察rememberGlidePainter的具体实现：\n@Composable fun rememberGlidePainter( request: Any?, requestManager: RequestManager = GlidePainterDefaults.defaultRequestManager(), shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange = ShouldRefetchOnSizeChange { _, _ -\u0026gt; false }, // 注意这里的requestBuilder，加载的结果类型已经被固定为drawable requestBuilder: (RequestBuilder\u0026lt;Drawable\u0026gt;.(size: IntSize) -\u0026gt; RequestBuilder\u0026lt;Drawable\u0026gt;)? = null, // 新的API也能开启fadeIn效果 fadeIn: Boolean = false, fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration, // 是不是很疑惑为什么这里有个占位图id的参数？Glide本身就支持占位图设置， // 在Build Request的时候设置不就行了吗？其实这个参数是给Compose预览模式用的 @DrawableRes previewPlaceholder: Int = 0, ): LoadPainter\u0026lt;Any\u0026gt; { // GlideLoader是加载逻辑实现类，稍后展示 val glideLoader = remember { GlideLoader(requestManager, requestBuilder) }.apply { // 这里的逻辑并不是多余的，要知道如果key没有变化，remember函数会直接返回上次计算的结果， // 这里想表达的是，对上次的结果调用apply，更新requestManager和requestBuilder this.requestManager = requestManager this.requestBuilder = requestBuilder } // rememberLoadPainter位于之前所说的imageloading-core的核心库 // 在0.13.0版本Coil和Glide都用到这个库来获取LoadPainter return rememberLoadPainter( loader = glideLoader, request = checkData(request), shouldRefetchOnSizeChange = shouldRefetchOnSizeChange, fadeIn = fadeIn, fadeInDurationMs = fadeInDurationMs, previewPlaceholder = previewPlaceholder ) } // checkData检查了request的类型 private fun checkData(data: Any?): Any? { when (data) { is Drawable -\u0026gt; { throw IllegalArgumentException(....) } is ImageBitmap -\u0026gt; { throw IllegalArgumentException(....) } is ImageVector -\u0026gt; { throw IllegalArgumentException(....) } is Painter -\u0026gt; { throw IllegalArgumentException(....) } } return data } imageloading-core这次如何抽象图片加载行为？我们先观察一下rememberLoadPainter的参数列表：\n@Composable fun \u0026lt;R\u0026gt; rememberLoadPainter( loader: Loader\u0026lt;R\u0026gt;, request: R?, shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange, fadeIn: Boolean = false, fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration, @DrawableRes previewPlaceholder: Int = 0, ): LoadPainter\u0026lt;R\u0026gt; {...} @Stable fun interface Loader\u0026lt;R\u0026gt; { fun load(request: R, size: IntSize): Flow\u0026lt;ImageLoadState\u0026gt; } 与0.6.2版本不同，加载逻辑实现类需要返回一个状态流Flow\u0026lt;ImageLoadState\u0026gt;，而不再是单一的ImageLoadState，虽然请求类型仍然是泛型的，但是已经不需要表达类似于RequestBuilder这样的泛型类型，如何构建、发起请求由Loader自己决定。\nImageLoadState的实现如下\nsealed class ImageLoadState { object Empty : ImageLoadState() data class Loading( val placeholder: Painter?, val request: Any, ) : ImageLoadState() data class Success( val result: Painter, val source: DataSource, val request: Any, ) : ImageLoadState() data class Error( val request: Any, val result: Painter? = null, val throwable: Throwable? = null ) : ImageLoadState() } 不难发现所有的图片加载结果都要求封装成Painter进行返回，但尴尬的是，Drawable与Painter并不是天生互通的类型（Compose 1.0.5只有三种Painter，BitmapPainter、VectorPainter、ColorPainter），好在Accompanist提供了一个DrawablePainter。不过话又说回来，为什么非得要求生产者Loader返回Painter不可呢？那是因为加载请求是多类型的，消费者LoadPainter其实无法确定生产者返回的结果的类型，自然也不确定如何绘制它，因此LoadPainter采用了类似于装饰者模式的设计，图片结果绘制交由State内的Painter完成。\nGlideLoader的实现如下：\ninternal class GlideLoader( requestManager: RequestManager, requestBuilder: (RequestBuilder\u0026lt;Drawable\u0026gt;.(size: IntSize) -\u0026gt; RequestBuilder\u0026lt;Drawable\u0026gt;)?, ) : Loader\u0026lt;Any\u0026gt; { var requestManager by mutableStateOf(requestManager) var requestBuilder by mutableStateOf(requestBuilder) /** * 不要删除callbackFlow上的显式类型\u0026lt;ImageLoadState\u0026gt;。IR编译器不喜欢隐式类型。 */ @Suppress(\u0026#34;RemoveExplicitTypeArguments\u0026#34;) @OptIn(ExperimentalCoroutinesApi::class) override fun load( request: Any, size: IntSize ): Flow\u0026lt;ImageLoadState\u0026gt; = callbackFlow\u0026lt;ImageLoadState\u0026gt; { var failException: Throwable? = null // 这里同时使用Target与Listener两种机制来监听加载状态，并向flow发送对应状态 // Target并不会去处理Success的状态，Listener已经抢先处理并拦截了Target的Success调用 val target = object : EmptyCustomTarget( if (size.width \u0026gt; 0) size.width else Target.SIZE_ORIGINAL, if (size.height \u0026gt; 0) size.height else Target.SIZE_ORIGINAL ) { override fun onLoadStarted(placeholder: Drawable?) { trySendBlocking( ImageLoadState.Loading( placeholder = placeholder?.let(::DrawablePainter), request = request ) ) } override fun onLoadFailed(errorDrawable: Drawable?) { trySendBlocking( ImageLoadState.Error( result = errorDrawable?.let(::DrawablePainter), request = request, throwable = failException ?: IllegalArgumentException(\u0026#34;Error while loading $request\u0026#34;) ) ) // Close the channel[Flow] channel.close() } override fun onLoadCleared(resource: Drawable?) { // Glide想要释放资源，所以我们需要清除结果，否则我们可能会绘制已经被回收的视图 trySendBlocking(ImageLoadState.Empty) // Close the channel[Flow] channel.close() } } val listener = object : RequestListener\u0026lt;Drawable\u0026gt; { override fun onResourceReady( drawable: Drawable, model: Any, target: Target\u0026lt;Drawable\u0026gt;, dataSource: com.bumptech.glide.load.DataSource, isFirstResource: Boolean ): Boolean { // 这里发送的Painter类型 trySendBlocking( ImageLoadState.Success( result = DrawablePainter(drawable), source = dataSource.toDataSource(), request = request ) ) // Close the channel[Flow] channel.close() // Return true so that the target doesn\u0026#39;t receive the drawable // 这里返回true，Target就收不到结果了 return true } override fun onLoadFailed( e: GlideException?, model: Any, target: Target\u0026lt;Drawable\u0026gt;, isFirstResource: Boolean ): Boolean { // Glide只为Listener派发错误的Exception，因此这里需要缓存一下 failException = e // 返回false，允许Target被回调onLoadFailed return false } } // Start the image request into the target requestManager.load(request) .apply { requestBuilder?.invoke(this, size) } .addListener(listener) .into(target) // Await the channel being closed and request finishing... awaitClose { // 这里没有调用Glide.clear()，因为clear之后Painter进行绘制的位图可能会被回收，这会报错 // See https://github.com/google/accompanist/issues/419 } } } 总体来说状态转换逻辑和以前类似，只不过使用callbackFlow生成数据流后，状态发送显得更加优雅了。\n接下来关注rememberLoadPainter的具体实现：\n/** 一个通用的 image loading painter，它为要实现的图像加载库提供Loader接口。应用程序通常不应该使用此功能，而更推荐使用在此基础上构建的扩展库，例如Coil和Glide库。 */ @Composable fun \u0026lt;R\u0026gt; rememberLoadPainter( loader: Loader\u0026lt;R\u0026gt;, request: R?, shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange, fadeIn: Boolean = false, fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration, @DrawableRes previewPlaceholder: Int = 0, ): LoadPainter\u0026lt;R\u0026gt; { val coroutineScope = rememberCoroutineScope() // Our LoadPainter. This invokes the loader as appropriate to display the result. val painter = remember(loader, coroutineScope) { LoadPainter(loader, coroutineScope) } painter.request = request painter.shouldRefetchOnSizeChange = shouldRefetchOnSizeChange // 缓存父布局的大小，在计算图片请求的大小时会参考此值 painter.rootViewSize = LocalView.current.let { IntSize(it.width, it.height) } // fadeIn动画的ColorFilter // 实现原理和0.6.2版本类似，也是修改了ColorFliter的alpha(透明度), // brightness(亮度),saturation(饱和度)，不过这次的ColorFliter由LoadPainter直接进行处理 animateFadeInColorFilter( painter = painter, enabled = { result -\u0026gt; // 从 disk/network 才去展示fadeIn动画 // 这使我们可以近似地只在“首次加载”时运行动画 fadeIn \u0026amp;\u0026amp; result is ImageLoadState.Success \u0026amp;\u0026amp; result.source != DataSource.MEMORY }, durationMs = fadeInDurationMs, ) // Our result painter, created from the ImageState with some composition lifecycle // callbacks // 我们的result painter，通过一些composition生命周期的回调从ImageState创建 updatePainter(painter, previewPlaceholder) return painter } LoaderPainter的实现如下。这里要特别注意RememberObserver这个接口，RememberObserver是一个能够实现对remember行为的观察的接口，如果composition记住或者遗忘的是一个RememberObserver对象，RememberObserver能够收到这个事件，这些事件对LoaderPainter很有用。因为LoaderPainter毕竟并不是一个Compose组件，但是它必须了解它所在的父组件在什么时候离开了屏幕被销毁了（例如高速滑动列表时），这样它能够及时取消对状态流Flow\u0026lt;ImageLoadState\u0026gt;的收集，这是避免发生图片闪烁、错位等问题的关键。\nclass LoadPainter\u0026lt;R\u0026gt; internal constructor( private val loader: Loader\u0026lt;R\u0026gt;, private val coroutineScope: CoroutineScope, ) : Painter(), RememberObserver { private val paint by lazy(LazyThreadSafetyMode.NONE) { Paint() } internal var painter by mutableStateOf\u0026lt;Painter\u0026gt;(EmptyPainter) // 这个ColorFilter和渐入动画有关 internal var transitionColorFilter by mutableStateOf\u0026lt;ColorFilter?\u0026gt;(null) // CoroutineScope for the current request private var requestCoroutineScope: CoroutineScope? = null /** * The current request object. */ var request by mutableStateOf\u0026lt;R?\u0026gt;(null) /** * The root view size. */ internal var rootViewSize by mutableStateOf(IntSize(0, 0)) /** * Lambda which will be invoked when the size changes, allowing * optional re-fetching of the image. */ var shouldRefetchOnSizeChange by mutableStateOf(ShouldRefetchOnSizeChange { _, _ -\u0026gt; false }) /** * The current [ImageLoadState]. * 被观察的ImageLoadState */ var loadState: ImageLoadState by mutableStateOf(ImageLoadState.Empty) private set private var alpha: Float by mutableStateOf(1f) private var colorFilter: ColorFilter? by mutableStateOf(null) /** * 执行图像加载请求时要使用的大小 */ private var requestSize by mutableStateOf\u0026lt;IntSize?\u0026gt;(null) // Painter内的属性，指定边界大小 override val intrinsicSize: Size get() = painter.intrinsicSize override fun applyAlpha(alpha: Float): Boolean { this.alpha = alpha return true } override fun applyColorFilter(colorFilter: ColorFilter?): Boolean { this.colorFilter = colorFilter return true } override fun DrawScope.onDraw() { // 根据Canvas的大小确定requestSize，是不是注意到requestSize的确定其实是存在延时的？ updateRequestSize(canvasSize = size) // 下面是一些绘制逻辑 val transitionColorFilter = transitionColorFilter if (colorFilter != null \u0026amp;\u0026amp; transitionColorFilter != null) { // If we have a transition color filter, // and a specified color filter we need to // draw the content in a layer for both to apply. // See https://github.com/google/accompanist/issues/262 drawIntoCanvas { canvas -\u0026gt; paint.colorFilter = transitionColorFilter canvas.saveLayer(bounds = size.toRect(), paint = paint) with(painter) { draw(size, alpha, colorFilter) } canvas.restore() } else { // Otherwise we just draw the content directly, using the filter with(painter) { draw(size, alpha, colorFilter ?: transitionColorFilter) } } } // RememberObserver的方法 // remember运行了计算的lambda但是composition没记住这个对象时回调 override fun onAbandoned() { // We\u0026#39;ve been abandoned from composition, so cancel our request scope requestCoroutineScope?.cancel() requestCoroutineScope = null } // RememberObserver的方法 // composition忘记了这个对象时回调 override fun onForgotten() { // We\u0026#39;ve been forgotten from composition, so cancel our request scope // onAbandoned和onForgotten时都会cancel运行中的协程 requestCoroutineScope?.cancel() requestCoroutineScope = null } // RememberObserver的方法 // 当composition成功记住此对象时调用。 override fun onRemembered() { // Cancel any on-going scope (this shouldn\u0026#39;t really happen anyway) // 先取消以前正running的协程 requestCoroutineScope?.cancel() // 为当前请求创建新的scope，这允许我们取消作用域，而不影响父作用域的作业。 val scope = coroutineScope.coroutineContext.let { context -\u0026gt; CoroutineScope(context + Job(context[Job])) }.also { requestCoroutineScope = it } // 我们已经被记住了，所以可以启动一个协程来观察当前的请求对象和请求大小。 // 每当这些值中的任何一个发生变化时，collectLatest块将运行并执行图像加载（任何正在进行的请求都将被取消）。 scope.launch { // combine方法如其名，能把两个流合并成一个流 // 不过为什么这里要使用snapshotFlow把State转化成流呢？ // 因为使用流来监听State变化的最大好处就是collectLatest能够 // 取消掉上一次的execute调用并启动新一轮的加载 combine( snapshotFlow { request }, snapshotFlow { requestSize }, transform = { request, size -\u0026gt; request to size } ).collectLatest { (request, size) -\u0026gt; execute(request, size) } } // 自动保险。如果没有从onDraw()获得合适的大小， // 我们会将请求大小更新为-1，-1，这将加载原始大小的图像。 scope.launch { if (requestSize == null) { // 32ms should be enough time for measure/layout/draw to happen. // 微妙的32毫秒 delay(32) if (requestSize == null) { // If we still don\u0026#39;t have a request size, resolve the size without // the canvas size // 没获取到Canvas大小，使用原始尺寸 updateRequestSize(canvasSize = Size.Zero) } } } } /** * 执行图片加载请求并根据结果更新loadState的方法 下面描述的是一些状态转换逻辑，比如如果请求为null，状态就转变为Empty */ private suspend fun execute(request: R?, size: IntSize?) { if (request == null || size == null) { // If we don\u0026#39;t have a request, set our state to Empty and return loadState = ImageLoadState.Empty return } // ... loader.load(request, size) .catch { throwable -\u0026gt; when (throwable) { is Error -\u0026gt; throw throwable is IllegalStateException -\u0026gt; throw throwable is IllegalArgumentException -\u0026gt; throw throwable else -\u0026gt; { emit( ImageLoadState.Error( result = null, throwable = throwable, request = request ) ) } } } .collect { loadState = it } // 上面collect收集了加载的状态，注意，代表图片结果的Painter没被设置到LoadPainter的字段内 } private fun updateRequestSize(canvasSize: Size) { requestSize = IntSize( width = when { // If we have a canvas width, use it... canvasSize.width \u0026gt;= 0.5f -\u0026gt; canvasSize.width.roundToInt() // 还记得这个rootViewSize吗？它在rememberLoadPainter函数内被设置 rootViewSize.width \u0026gt; 0 -\u0026gt; rootViewSize.width else -\u0026gt; -1 }, height = when { // If we have a canvas height, use it... canvasSize.height \u0026gt;= 0.5f -\u0026gt; canvasSize.height.roundToInt() // Otherwise we fall-back to the root view size as an upper bound rootViewSize.height \u0026gt; 0 -\u0026gt; rootViewSize.height else -\u0026gt; -1 }, ) } } 虽然说LoadPainter确实是实现了RememberObserver，但是，这个回调是怎么被注册的呢？答案藏在习以为常的remember函数中，传入remember的key，或者是calculation得出的值，它们如果是个RememberObserver，则会被插入到RememberManager的队列中，每当“记忆”和“遗忘”事件发生时都会得到通知。\n@Composable inline fun \u0026lt;T\u0026gt; remember( key1: Any?, calculation: @DisallowComposableCalls () -\u0026gt; T ): T { return currentComposer.cache(currentComposer.changed(key1), calculation) } // 注意检查key是否有变化的changed函数 @ComposeCompilerApi override fun changed(value: Any?): Boolean { return if (nextSlot() != value) { updateValue(value) true } else { false } } @PublishedApi @OptIn(InternalComposeApi::class) internal fun updateValue(value: Any?) { // 两个if分支我们都可以看到 rememberManager.remembering() // rememberManager.forgetting()这些调用 if (inserting) { writer.update(value) if (value is RememberObserver) { // 注意，判断value是不是RememberObserver record { _, _, rememberManager -\u0026gt; rememberManager.remembering(value) } } } else { val groupSlotIndex = reader.groupSlotIndex - 1 recordSlotTableOperation(forParent = true) { _, slots, rememberManager -\u0026gt; if (value is RememberObserver) { abandonSet.add(value) rememberManager.remembering(value) } when (val previous = slots.set(groupSlotIndex, value)) { is RememberObserver -\u0026gt; rememberManager.forgetting(previous) is RecomposeScopeImpl -\u0026gt; { val composition = previous.composition if (composition != null) { previous.composition = null composition.pendingInvalidScopes = true } } } } } } // RememberManager是个接口 internal interface RememberManager { /** * The [RememberObserver] is being remembered by a slot in the slot table. */ fun remembering(instance: RememberObserver) /** * The [RememberObserver] is being forgotten by a slot in the slot table. */ fun forgetting(instance: RememberObserver) ... } // RememberManager的实现类 private class RememberEventDispatcher( private val abandoning: MutableSet\u0026lt;RememberObserver\u0026gt; ) : RememberManager { private val remembering = mutableListOf\u0026lt;RememberObserver\u0026gt;() private val forgetting = mutableListOf\u0026lt;RememberObserver\u0026gt;() private val sideEffects = mutableListOf\u0026lt;() -\u0026gt; Unit\u0026gt;() override fun remembering(instance: RememberObserver) { forgetting.lastIndexOf(instance).let { index -\u0026gt; if (index \u0026gt;= 0) { forgetting.removeAt(index) abandoning.remove(instance) } else { remembering.add(instance) } } } override fun forgetting(instance: RememberObserver) { remembering.lastIndexOf(instance).let { index -\u0026gt; if (index \u0026gt;= 0) { remembering.removeAt(index) abandoning.remove(instance) } else { forgetting.add(instance) } } } fun dispatchRememberObservers() { // 派发forgetting和remembering事件的逻辑 if (forgetting.isNotEmpty()) { for (i in forgetting.size - 1 downTo 0) { val instance = forgetting[i] if (instance !in abandoning) { instance.onForgotten() } } } if (remembering.isNotEmpty()) { remembering.fastForEach { instance -\u0026gt; abandoning.remove(instance) instance.onRemembered() } } } // .... } 我们已经明白LoadPainter到底是怎么管理Loader返回的流结果了，最后一个需要注意的地方在函数updatePainter里，这个调用位于rememberLoadPainter最后，函数实现会根据图片加载State的变化来为LoadPainter设置Painter。不过这不是兜了个圈子吗？似乎也可以在collect更新State的同时把Painter更新一下？\n/** * 允许我们以状态观察当前结果。这个函数允许我们最小化重组范围，这样当loadState改变时，只有这个函数需要重新 * 启动。 */ @Composable private fun \u0026lt;R\u0026gt; updatePainter( loadPainter: LoadPainter\u0026lt;R\u0026gt;, @DrawableRes previewPlaceholder: Int = 0, ) { loadPainter.painter = if (LocalInspectionMode.current \u0026amp;\u0026amp; previewPlaceholder != 0) { // 如果我们处于检查模式（预览），并且有一个预览占位符，只需使用图像绘制它并返回 // 还记得rememberGlidePainter的参数吗？这里就是传入的参数previewPlaceholder的用途 // 这个函数令LoadPainter完全忽略了State的变化，只展示静态图片 painterResource(previewPlaceholder) } else { // remember在这里看上去像是毫无必要的调用， // 但这允许任何Painter实例接收记忆事件（如果它实现了RememberObserver）。不要移除。 remember(loadPainter.loadState) { loadPainter.loadState.painter } ?: EmptyPainter } } 现在来总结一下0.13.0版本的Glide远程图片扩展的实现思路：\n图片加载：依然是用Target回调获取加载的结果。但是加载状态的返回现在使用流（Flow）来封装，不管是发起加载，异常处理，加载取消都更加优雅直观了。Loader是彻彻底底的生产者，LoadPainter则是消费者。\nLoadPainter并不具有@Composable上下文，作为替代，它实现了RememberObserver来监听控件是否已经离屏销毁。\n图片大小约束：依赖于LoadPainter获取的Canvas的大小。\n渐入动画实现：跟0.6.2版本的思路相似，不过消费ColorFilter的类变成了LoadPainter。\nloading占位图、error图等：这些功能直接依赖于具体的图片加载框架的实现，有则有，无则无。0.13.0版本稍微舍去了一些灵活性，不能够像PicassoImage一样直接传入error、loading的Compose内容（控件），不过仍然留有监听图片加载状态的方式，注意，LoadPainter的loadState字段是公开的：\n/** * The current [ImageLoadState]. */ var loadState: ImageLoadState by mutableStateOf(ImageLoadState.Empty) private set Coil Accompanist内的Coil集成库最终集成到了Coil内部，成为其扩展，Glide的集成支持则在2021年8月的0.16.0版本被删除。\n现在我们简要分析Coil的图片加载逻辑（版本2.0.0-alpha06）。Coil扩展库提供了两种方式来加载网络图片，两种方式正巧就是上面提到的在0.6.2版本与在0.13.0版本的两种实现形式：\n// 实现形式1 @Composable fun AsyncImage( model: Any?, contentDescription: String?, imageLoader: ImageLoader, modifier: Modifier = Modifier, loading: @Composable (AsyncImageScope.(State.Loading) -\u0026gt; Unit)? = null, success: @Composable (AsyncImageScope.(State.Success) -\u0026gt; Unit)? = null, error: @Composable (AsyncImageScope.(State.Error) -\u0026gt; Unit)? = null, alignment: Alignment = Alignment.Center, contentScale: ContentScale = ContentScale.Fit, alpha: Float = DefaultAlpha, colorFilter: ColorFilter? = null, filterQuality: FilterQuality = DefaultFilterQuality, ) {...} // 实现形式2 @Composable fun rememberAsyncImagePainter( model: Any?, imageLoader: ImageLoader, filterQuality: FilterQuality = DefaultFilterQuality, ): AsyncImagePainter {...} 我们重点分析第二种形式，即rememberAsyncImagePainter函数，其实该函数的实现逻辑与Glide扩展库比较类似，只在某些细节有所区别：\n// 这里不再详细分析源码，挑重要的讲 @Composable fun rememberAsyncImagePainter( model: Any?, imageLoader: ImageLoader, filterQuality: FilterQuality = DefaultFilterQuality, ): AsyncImagePainter { val request = requestOf(model) requireSupportedData(request.data) // 注意这里，这里要求request的target为null require(request.target == null) { \u0026#34;request.target must be null.\u0026#34; } // Dispatchers.Main.immediate是一个有趣的协程调度器，具体效果见类注释 val scope = rememberCoroutineScope { Dispatchers.Main.immediate } // AsyncImagePainter val painter = remember(scope) { AsyncImagePainter(scope, request, imageLoader) } painter.request = request painter.imageLoader = imageLoader painter.filterQuality = filterQuality // 是否处于预览模式 painter.isPreview = LocalInspectionMode.current // 这里手动调用了一次onRemembered，onRemembered里有向ImageLoader提交request的逻辑 painter.onRemembered() // Invoke this manually so `painter.state` is up to date immediately. // 这里的updatePainter更加复杂，里面有处理fadeIn动画的逻辑 updatePainter(painter, request, imageLoader) return painter } Dispatchers.Main.immediate比单纯的Dispatchers.Main更加智能，它会减少不必要的调度，当它已经在正确的上下文中，它会立刻执行相应逻辑而无需额外的重新调度。效果类似于下面这样：\nsuspend fun updateUiElement(val text: String) { /* * 假设updateUiElement既会被Main线程调用也会被其他线程调用。 * 那么，当updateUiElement是在Main线程被调用的，更新uiElement.text 这段代码会直接运行，而换成Dispatchers.Main的话，它会再进行一次到Main的调度（明显这是赘余的调度）。 */ withContext(Dispatchers.Main.immediate) { uiElement.text = text } // Do context-independent logic such as logging } 接下来我们关注AsyncImagePainter的具体实现：\n/** * 异步执行ImageRequest并呈现结果的Painter。 */ class AsyncImagePainter internal constructor( private val parentScope: CoroutineScope, request: ImageRequest, imageLoader: ImageLoader ) : Painter(), RememberObserver { private var rememberScope: CoroutineScope? = null // 图片请求的协程的Job private var requestJob: Job? = null private var drawSize = MutableStateFlow(Size.Zero) private var alpha: Float by mutableStateOf(1f) private var colorFilter: ColorFilter? by mutableStateOf(null) internal var painter: Painter? by mutableStateOf(null) internal var filterQuality = DefaultFilterQuality internal var isPreview = false /** The current [AsyncImagePainter.State]. */ var state: State by mutableStateOf(State.Empty) private set var request: ImageRequest by mutableStateOf(request) internal set var imageLoader: ImageLoader by mutableStateOf(imageLoader) internal set override val intrinsicSize: Size get() = painter?.intrinsicSize ?: Size.Unspecified override fun DrawScope.onDraw() { // 绘制逻辑非常清爽 drawSize.value = size // Draw the current painter. painter?.apply { draw(size, alpha, colorFilter) } } ... override fun onRemembered() { // 如果我们处于检查模式（预览），请跳过执行图像请求，并将状态设置为加载。 // 对于预览模式的支持 if (isPreview) { val request = request.newBuilder().defaults(imageLoader.defaults).build() state = State.Loading(request.placeholder?.toPainter()) return } // 与Glide扩展类似，创建了一个子作用域 if (rememberScope != null) return val scope = parentScope + SupervisorJob(parentScope.coroutineContext.job) rememberScope = scope // 观察当前请求+请求大小，并根据需要启动新请求。 // Coil天然支持Kotlin协程，无需为生产者额外编写代码 scope.launch { snapshotFlow { request }.collect { request -\u0026gt; requestJob?.cancel() requestJob = launch { // execute是挂起函数，返回ImageResult state = imageLoader.execute(updateRequest(request)).toState() } } } } override fun onForgotten() { rememberScope?.cancel() rememberScope = null requestJob?.cancel() requestJob = null } override fun onAbandoned() = onForgotten() /** Update the [request] to work with [AsyncImagePainter]. */ private fun updateRequest(request: ImageRequest): ImageRequest { return request.newBuilder() .target( onStart = { placeholder -\u0026gt; // 这里获取到placeholder的Painter并更新State为Loading state = State.Loading(placeholder?.toPainter()) } ) .apply { if (request.defined.sizeResolver == null) { // Coil内关于设置图片大小的代码 // size接受一个SizeResolver，一个含suspend函数的接口 // 获取尺寸的函数是挂起函数，非常合理，因为很多时候需要等待控件测量完毕才知道大小 size(DrawSizeResolver()) } if (request.defined.precision != Precision.EXACT) { precision(Precision.INEXACT) } } .build() } private fun ImageResult.toState() = when (this) {....} private fun Drawable.toPainter() = when (this) {...} /** Suspends until the draw size for this [AsyncImagePainter] is unspecified or positive. */ private inner class DrawSizeResolver : SizeResolver { override suspend fun size() = drawSize .mapNotNull { size -\u0026gt; when { // mapNotNull会将drawSize转化为Flow，同时过滤null值，然后挂起函数first() // 将会返回Flow中传送的第一个值 size.isUnspecified -\u0026gt; CoilSize.ORIGINAL size.isPositive -\u0026gt; CoilSize(size.width.roundToInt(), size.height.roundToInt()) else -\u0026gt; null } } .first() } /** * The current state of the [AsyncImagePainter]. * 状态定义 */ sealed class State { abstract val painter: Painter? object Empty : State() { override val painter: Painter? get() = null } data class Loading( override val painter: Painter?, ) : State() data class Success( override val painter: Painter, val result: SuccessResult, ) : State() data class Error( override val painter: Painter?, val result: ErrorResult, ) : State() } } 与Glide扩展库的思路类似，updatePainter函数会监听AsyncImagePainter的加载状态变化，同时更新AsyncImagePainter内的Painter字段。\n@Composable private fun updatePainter( imagePainter: AsyncImagePainter, request: ImageRequest, imageLoader: ImageLoader ) { // This may look like a useless remember, but this allows any painter instances // to receive remember events (if it implements RememberObserver). Do not remove. // 与Glide扩展库一样，允许结果Painter实例接收remember事件（如果它实现了RememberObserver） val state = imagePainter.state val painter = remember(state) { state.painter } // 如果没有CrossfadeTransition（实现渐入变换）的话，直接设置imagePainter.painter并返回 val transition = request.defined.transitionFactory ?: imageLoader.defaults.transitionFactory if (transition !is CrossfadeTransition.Factory) { imagePainter.painter = painter return } // ValueHolder是一个包含static field的数据类，目的是储存state.painter的值， // 避免在state.painter值更新后函数rememberCrossfadePainter重组， // 与rememberUpdatedState有异曲同工之妙，估计是因为rememberUpdatedState没有 // 传入key的API（这里要监听request变化），所以这里提供了简易的避免重组的实现 val loading = remember(request) { ValueHolder\u0026lt;Painter?\u0026gt;(null) } if (state is State.Loading) loading.value = state.painter // 必须位于Success状态且图片是从网络或磁盘加载的，才允许启动Crossfade，否则返回即可 if (state !is State.Success || state.result.dataSource == DataSource.MEMORY_CACHE) { imagePainter.painter = painter return } // Set the crossfade painter. // 千呼万唤始出来的CrossfadePainter imagePainter.painter = rememberCrossfadePainter( key = state, start = loading.value, end = painter, scale = request.scale, durationMillis = transition.durationMillis, fadeStart = !state.result.isPlaceholderCached, preferExactIntrinsicSize = transition.preferExactIntrinsicSize ) } /** A simple mutable value holder that avoids recomposition. */ // 使用静态字段（static）避免重组 private class ValueHolder\u0026lt;T\u0026gt;(@JvmField var value: T) CrossfadePainter的实现如下：\n@Stable private class CrossfadePainter( private var start: Painter?, private val end: Painter?, private val scale: Scale, private val durationMillis: Int, private val fadeStart: Boolean, private val preferExactIntrinsicSize: Boolean, ) : Painter() { private var invalidateTick by mutableStateOf(0) private var startTimeMillis = -1L private var isDone = false private var maxAlpha: Float by mutableStateOf(1f) private var colorFilter: ColorFilter? by mutableStateOf(null) override val intrinsicSize get() = computeIntrinsicSize() override fun DrawScope.onDraw() { // 如果Alpha变化完毕，直接使用end绘制 if (isDone) { drawPainter(end, maxAlpha) return } // Initialize startTimeMillis the first time we\u0026#39;re drawn. val uptimeMillis = SystemClock.uptimeMillis() if (startTimeMillis == -1L) { startTimeMillis = uptimeMillis } // Alpha的百分比 = (当前时间 - 开始时间) / 持续时间 val percent = (uptimeMillis - startTimeMillis) / durationMillis.toFloat() val endAlpha = percent.coerceIn(0f, 1f) * maxAlpha val startAlpha = if (fadeStart) maxAlpha - endAlpha else maxAlpha isDone = percent \u0026gt;= 1.0 // Loading占位图渐出，Success图片结果渐入 drawPainter(start, startAlpha) drawPainter(end, endAlpha) if (isDone) { start = null } else { // Increment this value to force the painter to be redrawn. invalidateTick++ } } ... } 现在来总结一下Coil远程图片扩展的实现思路：\n图片加载：Coil对协程提供直接的支持，size函数、execute加载函数本身就是挂起函数，因此无需额外的转换逻辑。而AsyncImagePainter则使用Job来控制图片加载协程。\nAsyncImagePainter并不具有@Composable上下文，作为替代，它实现了RememberObserver来监听控件是否已经离屏销毁。\n图片大小约束：依赖于DrawContext的Size。\n渐入动画实现：依赖于DrawScope.onDraw()内的重绘行为，通过对透明度Alpha的百分比计算来实现，令Loading状态的占位图渐出，Success状态的最终结果渐入。\nloading占位图、error图等：由Coil提供具体的实现。\n根据上述分析我们可以发现，相比于Glide或是Picasso，基于Kotlin协程实现的图片加载库Coil，的确能够很轻松与Jetpack Compose配合工作。\n至此对扩展库的分析已经完毕。横向对比来说，无论是对Picasso还是Glide进行扩展，我们都得额外做一些处理，才能够令本身不支持协程的它们在Compose下正常工作。要注意的是，单纯使用自定义的Target把结果返回到某个State，这种简单的做法在列表中可能会遇到严重的性能问题，因为Glide也好，Picasso也好，它们内部实现中取消图片加载以避免图片错位、闪烁的重要参照物就是ImageView，随着列表滑动不断创建的自定义的Target无法被它们识别并进行相应处理。相比之下基于协程的Coil的加载能够变得简单得多，我们只需要利用Job本身就可以控制加载的协程。\n","permalink":"https://usagisang.github.io/posts/%E5%A6%82%E4%BD%95%E4%B8%BAcompose-image%E6%8F%90%E4%BE%9B%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%94%AF%E6%8C%81/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文是源码分析类文章\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e如何为Compose Image提供网络图片加载支持？目前（Compose 1.0.5）最好的选择似乎是使用图片框架Coil，Coil对Jetpack Compose相关的支持文档\u003ca href=\"https://coil-kt.github.io/coil/compose/\"\u003e在这\u003c/a\u003e。\u003c/p\u003e","title":"如何为Compose Image提供网络图片加载支持"},{"content":"不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是 RSA 是其中最容易让人理解的。下文将尝试对 RSA 实现的具体流程进行解析。\n寻找合适的加密、解密函数 我并不知道 RSA 最初的诞生经过了怎样的启发与灵光一闪，但仍有办法切入 RSA 的设计思路，现在，我们从它的实际效果：公钥加密，私钥解密来入手，尝试一步步分析它，了解它。\n我们首先面临的问题是，如果想要达到加解密的钥匙分开的效果，应当怎么做呢？\n先尝试使用数学语言抽象化描述一下这个问题：\n设加密函数为$f_1(m,e)$，m 为明文，e 为加密密钥，解密函数为$f_2(x,d)$，x 为密文，d 为解密密钥，那么，我们需要寻找函数$f_1$和$f_2$，使得：$m=f_2(f_1(m, e),d)$成立，经过函数$f_1$和$f_2$两次变换之后，我们需要能够把明文给还原回来。\n为了解决上面的问题，我们需要对两个数学知识有一定的了解，第一个是欧拉定理，第二个则是模算术。\n欧拉定理 $$ 若a,m均为正整数,且gcd(a,m)=1,则a^{\\varphi(m)}\\equiv 1 (\\mod m) $$ $gcd(a,m)$表示求数 a 和 m 的最大公因数，如果最大公因数为1，这两个数互质。\n其中$\\varphi(m)$是一个重要的数论函数：欧拉函数。$\\varphi(m)$表示小于等于m的正整数中与m互质的数的数目。显然，若 m 为素数，则$\\varphi(m)=m-1$。\n基本的模算术 如果 A 和 B 满足$A \\mod n=B\\mod n$，我们称之为 A 与 B 有同余关系，同余关系常常又表示成：$A\\equiv B (\\mod n)$。同余关系是一种等价关系。\n模的含义可以换算为普通乘式： $$ A\\mod B=C \\rightarrow A=kB+C $$ 基本的模加法和模乘法、模幂运算规则如下： $$ \\displaylines{ (A + B) \\mod C = (A \\mod C + B \\mod C) \\mod C \\\\ (A * B) \\mod C = ((A \\mod C) * (B \\mod C)) \\mod C \\\\ (A^B)\\mod C = (A\\mod C)^B \\mod C \\\\ } $$\n了解了模幂的规则，其实我们很快就能发现函数$f(a,x)=a^x\\mod m$很有趣，因为存在$f(f(a,e),d)=f(a,ed)$，即$(a^e \\mod m)^d \\mod m = a^{ed} \\mod m$成立，而$a^{ed} \\mod m$与$a^{\\varphi(m)}\\equiv 1 (\\mod m)$之间的相似度又不禁令我们遐想联翩。实际上，欧拉定理再变通一下，我们就能得到$a^{\\varphi(m)+1}\\mod m=a$，其中$a \u003c m$。那么，要是$ed=\\varphi(m)+1$的话，不就有$a^{ed} \\mod m=a^{\\varphi(m)+1}\\mod m=a$了吗？！那么，我们现在这样来描述我们的加解密函数$f_1$和$f_2$，令$f_1=f_2=a^x\\mod m$，其中 a 为明文，选择一个 $m$，计算 $\\varphi(m)$，公钥和私钥的策略是，然后选择一个 $e$ 并根据 $ed=\\varphi(m)+1$ 计算 $d$。\n经过上面的简单思考，我们来解决一些随之而来的问题。\n首先，我们为了得到 $a^{\\varphi(m)+1}\\mod m=a$，实际上弱化了欧拉定理，要求底数 $a \u003c m$。不过这并不是什么大问题，底数 a 代表的明文如果实在太长，我们把它分割一下，让它小于m就行了。\n其次，欧拉定理还要求底数 a 和模 m 互质（$gcd(a,m)=1$），这是一个比较严苛的要求。幸运的是，即使明文 a 与 m 不互质，我们也可以证明我们的加密、解密函数仍然有效，稍后将给出证明。\n另外，在实现上仍有诸多疑问：一个数的幂的结果增长得特别快，计算 $a^{ed}$ 是否很容易超出编程语言中整型变量的范围呢？如何根据 $n$ 确定$\\varphi(n)$？\n快速模幂 我们先来解决计算$a^{ed}\\mod n$的问题。\n例如，要求计算$2^{256}\\mod 7$。显然，先计算出$2^{256}$不是什么明智的选择。根据模算术的基本规则，我们可以得到： $$ 2^{256}\\mod 7=(2^{128}\\mod 7*2^{128}\\mod7)\\mod7 $$ 如何求$2^{128}\\mod 7$呢？答案是去求解$2^{64}\\mod 7$，这样循环递归下去，我们可以凭借$2\\mod 7$的结果计算$2^{256}\\mod 7$！这是基于分治思想得出的算法。\n不过，如果幂不能被2整除呢？例如求$3^{117}\\mod 7$。这时，关键在于如何对整数117按照2的若干次幂进行划分，其实117的二进制表示本身就是一种天然划分。把117表示成二进制：$117=(1110101)_2$，$3^{117}=3^{2^0+2^{2}+2^{4}+2^{5}+2^{6}}=3^1*3^4*3^{16}*3^{32}*3^{64}$\n我们可以使用动态规划的思想，自底向上进行迭代来求解这个问题。\n分析递推式，有$2^k\\mod n=(2^{k-1}\\mod n)^2\\mod n$，事实上动态规划表内第 k 项只和第 k-1 项有关，我们可以省略一个完整的动态规划表，只保留 k-1 项。\npublic static int fastModularExponentiation(int base, int power, int p) { // 缓存k-1项 int i = base % p; int result = 1; while (power \u0026gt; 0) { if ((power \u0026amp; 1) == 1) { result = (result * i) % p; } i = (i * i) % p; power = power \u0026gt;\u0026gt; 1; } return result; } 如何产生n与如何计算$\\varphi(n)$ 因为我们选定了$f(m,e)=m^e\\mod n$来进行加密运算，那么公钥 e 和模 n 都需要公开，其他人才可以进行加密。$n$ 被公开则触及一个核心的问题：既然 $n$ 被公开，$\\varphi(n)$ 不是很容易被计算出来吗？又有 $ed=\\varphi(n)+1$，那么密钥 $d$ 不是很容易确定吗？这样还存在保密性吗？\n首先，对于一个合数而言，欧拉函数$\\varphi(n)$的值其实不那么容易被计算出来，因为没有有效的算法来计算甚至估算这个函数的值，我们只能暴力地从1到$n-1$，一个个去尝试它是否与 n 互质。问题随之而来，如果公开的模 n 复杂到别人无法暴力破解$\\varphi(n)$，那么我们又凭什么能够快速算出$\\varphi(n)$呢？算法又需要这个值来生成公钥和私钥。\n下面的这个定理完美解决了上述问题 $$ 若p和q都是素数，n=pq，那么\\varphi(n)=\\varphi(p)\\varphi(q) $$ 以上定理不作证明，我们使用这个定理，轻易就能得出$\\varphi(n)=(p-1)(q-1)$，也就是说，只要找到 n 的两个素数因子，我们就能确定$\\varphi(n)$，以这种思路来计算$\\varphi(n)$的可行性基本上是……0。是的，当 n 相当大的时候，找出两个素数因子简直难如登天。我们不是采用这种方法来计算$\\varphi(n)$，而是以这种思路来生成 $n$，从而不费吹灰之力得到$\\varphi(n)$：先选择两个大素数 p 和 q，然后计算 n=pq，$\\varphi(n)$自然等于$(p-1)(q-1)$，而公开的公钥对{e，n}中，别人只拿到了 n，想计算出$\\varphi(n)、p、q$反而相当困难。\n公钥e和私钥d的生成 既然我们已经调整了 n 的生成过程，其实公钥 e 和私钥 d 的生成过程我们也需要调整了。因为要求$ed=\\varphi(n)+1$不一定能得到满足，我们不能保证$\\varphi(n)+1$一定是一个合数，为此不停生成 n 显得有点本末倒置，我们希望能够得到一个更简洁的公钥私钥生成过程。\n$ed=\\varphi(n)+1$不一定成立？没关系，我们可以加入一个系数 k，构造$ed=k*\\varphi(n)+1$，k 为整数，当 k=1 时不成立也不要紧，只要有一个 k 能使得上述式子成立就行了。加上 k 之后，$ed$ 的含义并没有改变，因为$a^{\\varphi(n)}\\equiv 1 (\\mod n)$成立意味着$a^{k\\varphi(n)+1}\\equiv a (\\mod n)$也成立。\n先不讨论是否真的存在一个这样的 k，我们先来化简一下这个式子。还记得模与普通算式的转换吗？ $$ ed=k*\\varphi(n)+1\\rightarrow ed\\equiv 1(\\mod \\varphi(n)) $$ 然后，上述式子还可以写为 $$ d= e^{-1}\\mod \\varphi(n) $$ d 称之为 e 的模逆元，不过 e 的模逆元的意思可不是 e 的倒数求模，而是求一个数 d 能使得 e 与 d 的乘积与1同余。\n经过修改，我们暂时把公钥 e 和私钥 d 的生成过程描述如下： $$ 选择一个公钥e，计算私钥d= e^{-1}\\mod \\varphi(n)。 $$ 现在我们再来思考这个问题：是否存在一个整数 k，使得$ed=k*\\varphi(n)+1$成立呢？如果不成立，私钥 d 就不存在了。需要什么前提条件使得 k 存在吗？\n解决这个问题需要引入线性同余方程的概念。 $$ 在数论中，形如ax\\equiv b(\\mod n)的形式的方程称之为线性同余方程 $$ 此方程有解当且仅当 $b$ 能够被 $a$ 与 $n$ 的最大公因数整除。该性质的详细证明忽略。由该性质得到下面的引理： $$ 设a和b不全为0，则存在整数x，y，使得gcd (a,b)=ax+by $$ 我们拿出方程式$ed\\equiv 1(\\mod \\varphi(n))$对比上面的同余方程一般式，就能发现，只要 e 和 $\\varphi(n)$ 的最大公因数为1(它们互质)，那么方程的解就存在，也就是私钥 d 存在。\n既然证明了私钥 d 是存在的，剩下的问题则是如何计算它。计算私钥 d 的核心思想是扩展欧几里得算法。\n提到欧几里得算法（GCD），相比各位不会陌生，这是一个求数 A 和 B 的最大公因数的高效算法，我们有 $$ gcd(a,b)=gcd(b, a\\mod b) $$ 该算法正确性的证明不作讨论，我们仅关注怎么使用它来解决同余方程，计算出我们想要的私钥d。\n下面是扩展欧几里得算法的思路： $$ \\begin{aligned} gcd(a,n)\u0026=ax_1+ny_1 \\\\ gcd(n, a \\% n) \u0026= nx_2+(a\\% n)y_2\\\\ \u0026=nx_2+(a-a/n*n)*y_2 \\\\ \u0026= nx_2+ay_2-a/n*n*y_2 \\\\ \u0026=ay_2+n(x_2-a/n*y_2) \\\\ \\end{aligned} $$ 因为$gcd(a,n)=gcd(n, a \\mod n)$，所以$x_1=y_2,y_1=x_2-a/n*y_2$，我们得到了计算 a 与 n 的最大公因数的过程中 x 和 y 的递推公式，据此可以写出算法的简单实现代码。\npublic static int x = 0; public static int y = 0; /** * 计算ax+ny=1的特解 */ public static int gcd(int a, int n) { if (n == 0) { x = 1; y = 0; return a; } else if (a == 0) { x = 0; y = 1; return n; } else { int c = gcd(n, a % n); int tmp = x; x = y; y = tmp - a / n * y; return c; } } 上面的静态变量 x 就是我们想要的私钥 d。现在，生成私钥 d 已经不是难题了。\nRSA算法全过程 我们已经差不多把 RSA 算法的全过程都解释了一遍，现在来浏览一下真正的 RSA 算法全过程吧。\n密钥生成 选择大素数 p 与 q，计算$n=pq$，$\\varphi(n)=(p-1)(q-1)$，然后丢弃 p 和 q，不保留。 在$1 \u003c e \u003c \\varphi(n)$的范围内选择整数公钥 e，使得$gcd(e,\\varphi(n))=1$（若 $e$ 和 $\\varphi(n)$ 不互质，则不存在私钥 $d$，这点上面已经证明过了）。 计算私钥 d，$d=e^{-1}\\mod \\varphi(n)$。 加密过程 发送方获得公钥对{e,n} 把明文 $m$ 分解为小于 n 的若干块 计算密文$C=m^e\\mod n$ 解密过程 接收方提前内置密钥对{d,n} 对密文解密$m=C^d\\mod n$ 尾声：RSA算法正确性证明 回到我们最开始先忽略的那一个问题，既然欧拉定理要求底数 a 与模 n 互质，当明文 a 与模 n 不互质的时候，还能够完成加密并解密的任务吗？先给出结论，结论是只要 a 不是模 n 的倍数，RSA 算法就是正确的。既然我们要求了$a \u003c n$，那么 a 是 n 的倍数的可能性不复存在。\n以下是证明： $$ 设n=pq，a是某一个整数、gcd(a,n)\\neq 1 且a不能被n整除，试证明a\\equiv a^{k\\varphi(n)+1}(\\mod n) $$\n$$ \\displaylines{ 若a与n不互质，必有p|a(a能被p整除)或者q|a。设p|a成立，必有gcd(q,a)=1，否则n|a，不符合题设条件。\\\\同理设q|a成立也是一样的情况，不失一般性，设p|a成立。 由欧拉定理和\\varphi(n)=(p-1)(q-1)得到：\\\\ a^{\\varphi(n)}\\equiv 1(\\mod q) \\\\ a^{k\\varphi(n)}\\equiv 1(\\mod q) \\\\ 令m为整数,有\\\\ a^{k\\varphi(n)}=mq+1\\\\ a^{k\\varphi(n) + 1}=maq+a\\\\ 将a分解为a=xp \\\\ a^{k\\varphi(n) + 1}=mxpq+a=mxn+a\\\\ 则a^{k\\varphi(n) + 1}\\equiv a(\\mod n)成立 } $$\n","permalink":"https://usagisang.github.io/posts/rsa/","summary":"\u003cp\u003e不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是 RSA 是其中最容易让人理解的。下文将尝试对 RSA 实现的具体流程进行解析。\u003c/p\u003e","title":"RSA"}]