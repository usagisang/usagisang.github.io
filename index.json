[{"content":"欧几里得算法的自然语言描述 计算两个非负整数p和q的最大公约数：若 q 是0，则最大公约数为p。否则，将 p 除以 q 得到余数 r，p和q的最大公约数即为 q 和 r 的最大公约数。\n递归实现 根据自然语言描述实现递归的 gcd 算法是比较容易的：\nint gcd(int p, int q) { if (q == 0) { return p; } int r = p % q; return gcd(q, r); } 非递归实现 由于递归版本的 gcd 是一个尾递归函数，因此改写为迭代版本的实现相对也较为容易。\n我们分析一下。gcd 算法的停止条件应当是余数为0。而在计算的过程中，我们一般需要三个变量的空间，用于存放 p、q 和它们的计算结果 r，如果计算仍需进行，我们需要将 q 的值移动至 p，r 的值移动至 q，这样就维护了p % q计算循环的正确性：\nint gcd(int p, int q) { int r = q; while (r != 0) { r = p % q; p = q; q = r; } return p; } 减少一个变量 上面的算法是不是可以减少一个变量的使用呢？\n如果我们不使用一个新变量 r 来存放p%q的计算结果，那么这个结果必须放在 p 或 q 所在的内存中。在上面的实现中，我们最终是要用 q 将 p 的值覆盖掉的，说明 p 的值在计算后变得不重要了，我们直接用计算结果覆盖：p = p % q\n那么，计算结果 r 现在放在p这个变量上，它需要和q交换一下位置。通用的交换算法需要用到三个变量，似乎我们依然无法避免多声明一个变量？未必，因为 gcd 算法使用的是整型变量，我们可以使用一种只有整型变量能使用的特殊技巧来交换二者的值。\n利用XOR交换两个整型变量 按位进行 XOR（异或运算）的规则很简单，若两个操作数相应的位不同则值为1，相同则值为0，比如 15 XOR 19：\n00001111 XOR 00010011 = 00011100 异或运算的本质是求出两个操作数在每一个位上的 diff 信息\n由于位只有两种状态，因此，一个操作数结合 diff 信息，得到另一个操作数是轻而易举的事情——只需要再进行一次异或。用简单的等式（注意不是赋值语句）来表示，即b=a^b^a。\n用扩展的角度来看，a、b、a^b 之间形成一种三角关系：a^b 代表 a 与 b 的 diff 信息，而 b 代表了 a 和 a^b 的 diff 信息，a 代表了 b 和 a^b 的 diff 信息。\n因而，只要我们知道这个三角关系的任意两个值，都可以计算得出第三个值。（异或的逆运算是自身）\n有两种角度理解 XOR：\n其一是从生成两个操作数的 diff 信息这个角度来理解，即，不同为1，相同为0\n其二是操作数根据 diff 信息还原出另一个操作数的角度来理解。我们把 diff 的每一个位理解成：若 diff 的某一位是0，说明希望保持这个位；若 diff 的某一位是 1，说明希望翻转这个位。\n根据异或运算的特点，我们可以做到只使用两个变量来交换两个整型：\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a^b; b = a^b; // 相当于a^b^b a = a^b; // 相当于a^b^a } 二元运算与整型变量交换 如何理解上面的代码呢？我们换个更简单的二元运算——加法，来进一步说明这个问题。使用加法来交换两个整型更加直观且直接（我们不这么做的理由是加法可能会导致结果溢出，因此显得不如异或可靠）\nvoid swap(int \u0026amp;a, int \u0026amp;b) { a = a + b; // 先计算一个同时包含a和b的结果 b = a - b; // 通过b进行逆运算, 求原来的a a = a - b; // 通过原来的a进行逆运算，求原来的b } 仔细对比使用异或运算或加减法运算对整型变量进行交换的步骤，我们可以更清楚地知道二元运算是怎么产生作用的。\n首先，我们用可逆的二元运算，计算出一个同时包含操作数 a 和 b 的结果，然后使用逆运算还原想要的另一个操作数即可达成变量交换的效果。对于异或运算来说，它的逆运算就是其自身。\n另一个版本的gcd 我们知道如何使用二元运算交换整型变量后，照葫芦画瓢修改原来的 gcd 算法即可：\nint gcd_no(int p, int q) { while (q != 0) { p = p % q; p = p^q; q = p^q; p = p^q; } return p; } 这个算法会更高效吗？答案是未必，它虽然减少了一个栈变量的使用，但是却可能增加了一次内存访问。\n","permalink":"https://usagisang.github.io/posts/gcd%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/","summary":"\u003ch2 id=\"欧几里得算法的自然语言描述\"\u003e欧几里得算法的自然语言描述\u003c/h2\u003e\n\u003cp\u003e计算两个非负整数p和q的最大公约数：若 q 是0，则最大公约数为p。否则，将 p 除以 q 得到余数 r，p和q的最大公约数即为 q 和 r 的最大公约数。\u003c/p\u003e\n\u003ch2 id=\"递归实现\"\u003e递归实现\u003c/h2\u003e\n\u003cp\u003e根据自然语言描述实现递归的 gcd 算法是比较容易的：\u003c/p\u003e","title":"gcd的递归与非递归实现"},{"content":" 本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\n开机动画文件路径 系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\n/apex/com.android.bootanimation/etc/bootanimation.zip (since Android 10) /product/media/bootanimation.zip (since Android 9) /oem/media/bootanimation.zip /system/media/bootanimation-encrypted.zip (if getprop(\u0026#34;vold.decrypt\u0026#34;) = \u0026#39;1\u0026#39;) /system/media/bootanimation.zip 注释1：搜索 /product 分区的特性在 Android 9 被添加，搜索/apex 分区的特性在 Android 10 才被添加，按照历史惯性而言，厂商默认的开机动画一般保存在/system分区。\n注释2：vold.decrypt属性表明此 Android 系统开启了全盘加密。全盘加密特性从 Android 10 开始已被废弃，只有在启用此特性的机器上才需要特别关注bootanimation-encrypted.zip文件。\n文件结构 bootanimation.zip一般包含以下文件：\ndesc.txt - 描述如何执行动画的文本文档 part0 \\ part1 \\ 文件夹，包含一段动画所有的帧，这些帧以PNG文件保存 ... / partN / bootanimation.zip允许定义多个不同的动画片段，并把它们串联在一起组成完整的开机动画，这些动画片段存储在不同的partN文件夹里，其中 N 指的是序号的数字。\npartN文件夹里除了包含一帧帧 PNG 图片，还可以包含一些其他资源或配置文件。\ndesc.txt 第一行定义动画的通用参数\nWIDTH HEIGHT FPS [PROGRESS] WIDTH: 动画宽度（像素） HEIGHT: 动画高度（像素） FPS: 每秒帧数，例如60 PROGRESS：（可选，since Android 12），是否显示最后一个动画片段的进度百分比 百分比将水平居中，y 坐标将被设置为动画高度的1/3。 第二行以及以后的若干行定义一个动画片段：\nTYPE COUNT PAUSE PATH [#RGBHEX [CLOCK1 [CLOCK2]]] TYPE: 单个字符，或$SYSTEM，指示动画片段的类型： p: 播放这段动画，但会被开机完成事件打断 c: 完整播放这段动画，即使开机完成, 动画也不会被打断 $SYSTEM: 加载 /system/media/bootanimation.zip 并播放它。 COUNT: 最大播放多少次动画，如果设置为 0，则动画无限循环直到启动完成 PAUSE: 该部分结束后延迟多少帧再播放下一个动画片段 PATH: 动画资源目录（例如part0） RGBHEX: （可选）背景颜色，格式为#RRGGBB CLOCK1、CLOCK2：（可选）绘制当前时间的坐标（对于手表）： 如果仅提供CLOCK1，则它会被解析为时钟的 y 坐标，时钟的 x 坐标默认为c （since Android 9）如果同时提供了CLOCK1和CLOCK2，则第一个作为 x 坐标，第二个作为 y 坐标 值可以是正整数、负整数或c c：将文本居中 正整数n，：x 坐标，从屏幕左边缘开始算起的像素，y 坐标，从屏幕下边缘开始算起的像素 -n：x 坐标，从屏幕右边缘开始算起的像素，y 坐标，从屏幕上边缘开始算起的像素 例子： -24或者c -24，将文本定位在距屏幕顶部 24 像素处，水平居中 16 c，将文本定位在距屏幕左侧 16 像素处，垂直居中 -32 32，将文本定位在屏幕右侧 32 像素、底边缘上方 32 像素处 注意，同时指定时钟的 x、y 坐标是从 Android 9.0 开始支持的特性，Android 9.0 以前只支持指定 y 坐标\nclock_font.png(since Android 9) 可以使用该文件指定绘制时间使用的字体。字体文件格式要求如下：\n该文件指定 ASCII 字符 32-127 (0x20-0x7F) 的字形，包括常规粗细和粗体粗细。 图像被划分为字符网格 有16列和6行 每行分为两半部分：上半部分为常规粗细字形，下半部分为粗体字形。 对于 NxM 大小的图像，每个字符字形的宽度为 N/16 像素，高度为 M/(12*2) 像素 加载和播放动画帧 每部分的动画都直接从 zip 文件中扫描并加载。在partN目录下，每个文件（除了trim.txt和audio.wav，请参阅下一节）都应该是一个 PNG 文件，表示该动画中的一帧（以指定的分辨率）。因此，必须按顺序命名动画帧（比如part000.png、part001.png）并按该顺序添加到 zip 文件中。\ntrim.txt 可以对动画帧进行缩放，只需要在partN目录下提供trim.txt 文件即可。这个文件按顺序列出其目录中每个帧的缩放输出，因此可以将动画帧放在合适的位置上。输出应采用以下形式：WxH+X+Y，其中W和H表示重新放大或缩小后的动画帧大小。例如：\n713x165+388+914 708x152+388+912 707x139+388+911 649x92+388+910 如果不提供该文件，则假定每个帧的大小与desc.txt中指定的宽高参数相同。\naudio.wav 每个动画片段可以选择在开始时播放wav。要启用此功能，请在partN目录下提供audio.wav文件。\n退出开机动画 系统完成启动后将结束开机动画（仍会播放任何没播完甚至还没开始播放的类型为c的开机动画），这是通过将系统属性service.bootanim.exit设置为非零字符串来完成的。\n提示 PNG压缩 可以使用zopflipng或pngcrush来压缩 PNG 图像。例如：\nfor fn in *.png ; do zopflipng -m ${fn}s ${fn}s.new \u0026amp;\u0026amp; mv -f ${fn}s.new ${fn} # or: pngcrush -q .... done 如果允许将动画减小到256种颜色，压缩效果会更好，酌情使用：\npngquant --force --ext .png *.png # alternatively: mogrify -colors 256 anim-tmp/*/*.png 如何创建 ZIP cd \u0026lt;path-to-pieces\u0026gt; zip -0qry -i \\*.txt \\*.png \\*.wav @ ../bootanimation.zip *.txt part* 请注意，ZIP 文件的压缩等级为0，实际上并未压缩！（使用其他压缩等级会导致读取文件失败） 因为 PNG 文件已经尽可能压缩，文件之间不太可能有任何冗余。\n开机动画与动态颜色(since Android 12L) 从 Android 12L 开始，Google 团队将 Android 12 引入的Dynamic color特性也应用到了开机动画上。在此模式下，开机动画不再直接渲染 PNG 图像，而是将 PNG 图像的 R、G、B、A 通道视为动态颜色的 mask（掩码），根据动画的进度，在开始颜色和结束颜色之间进行插值。\n要启用动态颜色特性，需要在 desc.txt 的第二行添加以下文本：\ndynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4 PATH： 要应用动态颜色过渡的部分的文件路径。该片段之前的任何部分都将以起始颜色渲染。之后的任何部分都将以最终颜色渲染。 RGBHEX1： 第一个起始颜色（masked by the R channel），指定为#RRGGBB。 RGBHEX2： 第二个起始颜色（masked by the G channel），指定为#RRGGBB。 RGBHEX3： 第三个起始颜色（masked by the B channel），指定为#RRGGBB。 RGBHEX4： 第四个起始颜色（masked by the A channel），指定为#RRGGBB。 将从以下系统属性中读取结束颜色：\npersist.bootanim.color1 persist.bootanim.color2 persist.bootanim.color3 persist.bootanim.color4 如果上面的某个系统属性为空，相应的结束颜色将默认为开始颜色，这样不会产生颜色转换。\n准备您的PNG图像，使 R、G、B、A 通道分别指示要绘制color1、color2、color3和color4的区域。\n动态颜色与开机动画的关系 简单来说，动态颜色是根据用户的相关设置（比如壁纸）等动态生成主题颜色调色板，并应用到系统上的过程。主题色变更后，系统将其更新在系统属性persist.bootanim.color1到persist.bootanim.color4上，也就是上文所说的结束颜色，开机动画通过读取系统属性并应用到动画上以支持动态颜色。\n但经过上文的分析，我们也都清楚开机动画实际由一张张 PNG 图片组成的，图片上的颜色肯定是固定的，那么如何做到动态着色呢？\n其实，图像本质上是保存“坐标”到“颜色”的映射的二维数组，想要支持动态颜色，我们需要给出“图像上的颜色”到“系统的动态颜色”的映射，那么解决方式就很简单了：\n首先，我们从动画中提炼几种主要出现的固定颜色并把它们映射到动态颜色上，对比上面的描述，这一步相当于在desc.txt中填写dynamic_colors PATH #RGBHEX1 #RGBHEX2 #RGBHEX3 #RGBHEX4，每一个被填上去的固定颜色会被映射到相应的系统属性。\n接下来，原来的动画帧中不应再保存固定颜色，而是保存这些颜色的“索引”，比如说我们简单用1、2、3、4来索引四种固定颜色，0表示没有任何颜色，那么，一个3x3的图像看起来可能像这样：\n[0, 0, 0], [0, 1, 2], [0, 4, 3] 这种索引方式没有任何问题，只是稍显笨拙。除了简单的索引值，我们还可以考虑混合四种固定颜色的情况，即用四维向量来表示一个位置上的颜色，向量的分量表示混合了多少对应的固定颜色，这类似于我们用 RGB 来表示颜色，只不过现在三原色变成了“四原色”（姑且不考虑这四种颜色能不能组成正交基）。我们如何保存向量的分量值呢？原来的 PNG 图像在这时就派上了用场，PNG 图像有 ARGB 四个颜色通道，正好对应向量的四个分量！\n如果有助于你理解的话，你还可以认为我们将图像的标准正交基从纯色变换为其他颜色\nBootAnimation.cpp 中的 glsl 代码如下：\nprecision mediump float; const float cWhiteMaskThreshold = 0.05; uniform sampler2D uTexture; uniform float uFade; uniform float uColorProgress; uniform vec3 uStartColor0; uniform vec3 uStartColor1; uniform vec3 uStartColor2; uniform vec3 uStartColor3; uniform vec3 uEndColor0; uniform vec3 uEndColor1; uniform vec3 uEndColor2; uniform vec3 uEndColor3; varying highp vec2 vUv; void main() { vec4 mask = texture2D(uTexture, vUv); float r = mask.r; float g = mask.g; float b = mask.b; float a = mask.a; // If all channels have values, render pixel as a shade of white. float useWhiteMask = step(cWhiteMaskThreshold, r) * step(cWhiteMaskThreshold, g) * step(cWhiteMaskThreshold, b) * step(cWhiteMaskThreshold, a); // 图像的rgba现在变为了动态颜色的系数, 这意味着它们共同指导了某个像素应当混合哪几类基色，并且每种基色混合到什么程度 vec3 color = r * mix(uStartColor0, uEndColor0, uColorProgress) + g * mix(uStartColor1, uEndColor1, uColorProgress) + b * mix(uStartColor2, uEndColor2, uColorProgress) + a * mix(uStartColor3, uEndColor3, uColorProgress); // 如果图像的rgba都有值，那么将会求rgba的平均值, 并将这个平均值作为颜色的三个分量，也就是说颜色变成灰色或白色 color = mix(color, vec3((r + g + b + a) * 0.25), useWhiteMask); gl_FragColor = vec4(color.x, color.y, color.z, (1.0 - uFade)); } 调试技巧 如果希望在运行中的系统调试开机动画，请顺序执行以下命令：\nadb root adb remount // 覆盖系统中原本的开机动画，push命令的路径应根据实际情况修改 adb push .\\bootanimation.zip /system/media/bootanimation.zip // 这个属性标记了开机动画是否应当退出, 重置这个标志以保证开机动画会被执行(即使类型为p) adb shell setprop service.bootanim.exit 0 adb shell setprop ctl.start bootanim 如果开机动画被配置为无限循环，再次执行以下命令（重新置位）才能终止开机动画：\nadb shell setprop service.bootanim.exit 1 ","permalink":"https://usagisang.github.io/posts/android%E5%BC%80%E6%9C%BA%E5%8A%A8%E7%94%BB%E4%BF%AE%E6%94%B9%E6%8C%87%E5%8D%97/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文内容的基本骨架来源于对 frameworks/base/cmds/bootanimation/FORMAT.md 的整合翻译。以下介绍的所有内容只适用于 AOSP ，厂商可针对 BootAnimation.cpp 进行魔改，请以具体代码为准。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"开机动画文件路径\"\u003e开机动画文件路径\u003c/h2\u003e\n\u003cp\u003e系统按优先级顺序从以下路径选择归档为 zip 文件的开机动画，第一个路径的优先级最高，然后依次递减：\u003c/p\u003e","title":"Android开机动画修改指南"},{"content":"关于三维空间中的旋转，我们以前提到过基于欧拉角的旋转表达矩阵，它们分别描述了围绕 x 轴、y 轴、z 轴旋转后坐标应当如何变化。事实上，我们可以更进一步，推导出一个通用的、围绕过原点的任意轴旋转的公式。\n题设 这一节我们来描述我们已知的条件和待求的目标：\n给定一个方向向量$\\vec{u}$作为旋转轴，$\\vec{v}$为待旋转的向量，我们希望得到$\\vec{v}$围绕着$\\vec{u}$逆时针旋转$\\theta$角度之后的向量$\\vec{v'}$。注意，$\\vec{v'}$的表达式必须用已知条件$\\vec{u}$、$\\vec{v}$和$\\theta$来表达。\n思路 旋转前后向量的长度不会变化，反而是如何计算旋转后向量的方向成为了一个难题。我们采用分解向量的思路来解决向量旋转的问题——把$\\vec{v}$分解为平行于$\\vec{u}$的向量$\\vec{v_{//}}$和垂直于$\\vec{u}$的向量$\\vec{v_\\bot}$，分解的示意图如下：\n这样定义向量的分解方式是有好处的，我们可以发现，旋转前后$\\vec{v_{//}}$没有变化，而旋转前的$\\vec{v_\\bot}$、旋转后的$\\vec{v'_\\bot}$都在一个平面内，同一个平面内的旋转比起三维旋转要好解决的多。\n公式推导 $\\vec{v_{//}}$实际上是$\\vec{v}$在$\\vec{u}$上的正交投影，因此我们可以得出： $$ \\begin{align} \\vec{v_{//}}\u0026=|\\vec{v}|\\frac{\\vec{u}\\cdot\\vec{v}}{|\\vec{u}|\\cdot|\\vec{v}|}\\cdot\\frac{\\vec{u}}{|\\vec{u}|}\\\\ \u0026=\\frac{\\vec{u}\\cdot\\vec{v}}{|\\vec{u}|^2}\\vec{u}\\\\ \u0026=(\\vec{u}\\cdot{\\vec{v}})\\vec{u} \\end{align} $$ 然后，我们运用向量减法给出$\\vec{v_{\\bot}}$的表达式： $$ \\vec{v_{\\bot}}=\\vec{v}-\\vec{v_{//}} $$ 接下来，我们需要给出$\\vec{v\u0026rsquo;_\\bot}$的表达式。给出一个直观的旋转俯视图：\n先定义$\\vec{w}$。引入这个向量是为了正交分解$\\vec{v'_\\bot}$，因此它必须垂直于$\\vec{v_{\\bot}}$。如果你对叉乘很熟悉的话，很快就能想到我们可以用$\\vec{u}\\times\\vec{v}$来得到具有这样的性质的向量。注意叉乘的顺序，根据旋转示意图和右手定则，$\\vec{u}\\times\\vec{v_{\\bot}}$的向量方向才是俯视图中的$\\vec{w}$方向。\n然后，我们把$\\vec{v'_\\bot}$正交分解成平行于$\\vec{v_{\\bot}}$的$\\vec{v'_{v}}$和平行于$\\vec{w}$的$\\vec{v'_w}$，并给出$\\vec{v'_\\bot}$的表达式。 $$ \\displaylines{ \\vec{v'_\\bot}=\\vec{v'_{v}}+\\vec{v'_w}\\\\ \\vec{v'_{v}}=|\\vec{v_\\bot}|\\cos\\theta\\cdot\\frac{\\vec{v_\\bot}}{|\\vec{v_\\bot}|}=\\vec{v_\\bot}\\cos\\theta\\\\ \\vec{v'_w}=|\\vec{v_\\bot}|\\sin\\theta\\cdot\\frac{\\vec{u}\\times\\vec{v_{\\bot}}}{|\\vec{u}\\times\\vec{v_{\\bot}}|}\\\\ |\\vec{u}\\times\\vec{v_{\\bot}}|=|\\vec{u}||\\vec{v_{\\bot}}|\\sin(\\pi/2)=|\\vec{v_{\\bot}}|\\\\ \\vec{v'_w}=(\\vec{u}\\times\\vec{v_{\\bot}})\\sin\\theta\\\\ \\vec{v'_\\bot}=\\vec{v_\\bot}\\cos\\theta+(\\vec{u}\\times\\vec{v_{\\bot}})\\sin\\theta } $$ 上面的式子可以进一步被化简，我们代入$\\vec{v_{\\bot}}$的表达式，并运用叉乘的分配律： $$ \\displaylines{ \\vec{v'_\\bot}=(\\vec{v}-\\vec{v_{//}})\\cos\\theta+(\\vec{u}\\times(\\vec{v}-\\vec{v_{//}}))\\sin\\theta\\\\ 使用分配律，(\\vec{u}\\times(\\vec{v}-\\vec{v_{//}}))=\\vec{u}\\times\\vec{v}-\\vec{u}\\times\\vec{v_{//}}\\\\ 因为共线，\\vec{u}\\times\\vec{v_{//}}=0\\\\ \\vec{v'_\\bot}=\\vec{v}\\cos\\theta-\\vec{v_{//}}\\cos\\theta+(\\vec{u}\\times\\vec{v})\\sin\\theta } $$ 最后，我们终于可以给出$\\vec{v\u0026rsquo;}$的表达式： $$ \\begin{aligned} \\vec{v'}\u0026=\\vec{v_{//}}+\\vec{v'_{\\bot}}\\\\ \u0026=\\vec{v_{//}}+\\vec{v}\\cos\\theta-\\vec{v_{//}}\\cos\\theta+(\\vec{u}\\times\\vec{v})\\sin\\theta\\\\ \u0026=\\vec{v}\\cos\\theta+(1-\\cos\\theta)\\vec{v_{//}}+(\\vec{u}\\times\\vec{v})\\sin\\theta\\\\ \u0026=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\end{aligned} $$ 因此： $$ \\vec{v'}=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\tag{1} $$ 公式（1）即为标题中的 Rodrigues’ Rotation Formula。\n化简为矩阵 我们需要进一步化简公式，得到其等价的矩阵表达形式，才方便代码的实现。\n首先，我们需要知道向量三重积公式： $$ \\vec{a}\\times(\\vec{b}\\times\\vec{c})=(\\vec{a}\\cdot\\vec{c})\\cdot\\vec{b}-(\\vec{a}\\cdot\\vec{b})\\cdot\\vec{c} \\tag{2} $$ 然后，我们还需要知道，向量的叉乘与矩阵之间的联系： $$ \\vec{a}\\times\\vec{b}=\\begin{pmatrix}y_az_b-z_ay_b\\\\z_ax_b-x_az_b\\\\x_ay_b-y_ax_b\\end{pmatrix}=A\\cdot b= \\begin{pmatrix} 0 \u0026 -z_a \u0026 y_a\\\\ z_a\u0026 0 \u0026 -x_a\\\\ -y_a\u0026 x_a \u0026 0 \\end{pmatrix}\\begin{pmatrix}x_b\\\\y_b\\\\z_b\\end{pmatrix} \\tag{3} $$ 向量的叉乘可以化为矩阵与向量的乘积，而且需要注意的是，矩阵只与左边的向量有关。\n我们化简的目标是得到下述形式的表达式，其中M是矩阵。 $$ \\vec{v'}=M\\cdot\\vec{v} $$ 再次观察公式（1）： $$ \\vec{v'}=\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}+(\\vec{u}\\times\\vec{v})\\sin\\theta \\tag{1} $$ 对于第一项和第三项来说，它们都可以快速化为等价的矩阵形式，其中，$\\vec{v}\\cos\\theta$可以化为： $$ \\vec{v}\\cos\\theta=\\begin{pmatrix} \\cos\\theta \u0026 0 \u0026 0\\\\ 0 \u0026 \\cos\\theta \u0026 0\\\\ 0 \u0026 0 \u0026 \\cos\\theta \\end{pmatrix}\\cdot\\vec{v} $$ 正如前文所说，$(\\vec{u}\\times\\vec{v})\\sin\\theta$可以利用公式（3）将叉乘化成矩阵乘向量的形式，这里记向量$\\vec{u}$形成的矩阵为$R_u$，可以得到： $$ (\\vec{u}\\times\\vec{v})\\sin\\theta=R_u\\sin\\theta\\cdot\\vec{v} \\tag{4} $$ 比较难以化简的是第二项，处于外部的是向量$\\vec{u}$而不是$\\vec{v}$，这给我们带来了一些麻烦。观察$(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$这一项和已知的三重积公式（2），或许可以想办法配凑另外一项，从而把点乘变为叉乘，再运用叉乘的性质化作矩阵。有好几种可能的叉乘式，最终我们选择配凑出这样的叉乘：$\\vec{u}\\times(\\vec{u}\\times\\vec{v})$。其中一个理由是$\\vec{u}$都在左边，我们可以复用前面提到的矩阵$R_u$；另一个理由是缺失的那一项很好配凑： $$ \\vec{u}\\times(\\vec{u}\\times\\vec{v})=(\\vec{u}\\cdot\\vec{v})\\vec{u}-(\\vec{u}\\cdot\\vec{u})\\vec{v}=(\\vec{u}\\cdot\\vec{v})\\vec{u}-\\vec{v} $$ 我们已经有了$(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$这一项，而且它的系数是$(1-\\cos\\theta)$，那么接下来就要配凑出$-(1-\\cos\\theta)\\vec{v}$这一项了。这很简单，我们结合公式（1）的第一项 $\\vec{v}\\cos\\theta$： $$ \\begin{aligned} \\vec{v}\\cos\\theta \u0026=\\vec{v}\\cos\\theta+\\vec{v}-\\vec{v}\\\\ \u0026=\\vec{v}-(1-\\cos\\theta)\\vec{v} \\end{aligned} $$ 因此，我们可以将公式（1）的前两项$\\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}$化简为： $$ \\begin{aligned} \\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u} \u0026=\\vec{v}-(1-\\cos\\theta)\\vec{v}+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}\\\\ \u0026=\\vec{v}+(1-\\cos\\theta)((\\vec{u}\\cdot{\\vec{v}})\\vec{u}-\\vec{v})\\\\ \u0026=\\vec{v}+(1-\\cos\\theta)(\\vec{u}\\times(\\vec{u}\\times\\vec{v})) \\end{aligned} $$ 最终我们如愿以偿得到了两重叉乘：$\\vec{u}\\times(\\vec{u}\\times\\vec{v})$。不过，两重叉乘也可以运用公式（3）吗？当然可以，运用两遍即可。而且，由于矩阵内的所有参数只和叉乘式的左边有关，因此我们会得到两个相同的矩阵： $$ \\begin{aligned} \\vec{u}\\times(\\vec{u}\\times\\vec{v}) \u0026=\\vec{u}\\times(R_u\\cdot\\vec{v})\\\\ \u0026=R_u\\cdot (R_u\\cdot\\vec{v})\\\\ \u0026=R_u^2\\cdot\\vec{v} \\end{aligned} $$ 我们得以将公式（1）的前两项化作矩阵向量乘法： $$ \\vec{v}\\cos\\theta+(1-\\cos\\theta)(\\vec{u}\\cdot{\\vec{v}})\\vec{u}=\\vec{v}+(1-\\cos\\theta)\\cdot R_u^2\\cdot\\vec{v} \\tag{5} $$ 最后，结合（4）与（5），我们将公式（1）化简为： $$ \\displaylines{ \\vec{v'}=\\vec{v}+(1-\\cos\\theta)\\cdot R_u^2\\cdot\\vec{v}+R_u\\sin\\theta\\cdot\\vec{v}\\\\ 记I为单位矩阵，则\\\\ \\vec{v'}=(I+(1-\\cos\\theta)\\cdot R_u^2+R_u\\sin\\theta)\\cdot\\vec{v}\\\\ } $$ 矩阵 $$ M=I+(1-\\cos\\theta)\\cdot R_u^2+R_u\\sin\\theta \\tag{6} $$ 即为我们所求的矩阵。\nRefer 罗德里格旋转公式（Rodrigues\u0026rsquo; rotation formula）\n四元数与三维旋转\n","permalink":"https://usagisang.github.io/posts/rodrigues-rotation-formula/","summary":"\u003cp\u003e关于三维空间中的旋转，我们以前提到过基于欧拉角的旋转表达矩阵，它们分别描述了围绕 x 轴、y 轴、z 轴旋转后坐标应当如何变化。事实上，我们可以更进一步，推导出一个通用的、围绕过原点的任意轴旋转的公式。\u003c/p\u003e","title":"Rodrigues’ Rotation Formula"},{"content":"不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是 RSA 是其中最容易让人理解的。下文将尝试对 RSA 实现的具体流程进行解析。\n寻找合适的加密、解密函数 我并不知道 RSA 最初的诞生经过了怎样的启发与灵光一闪，但仍有办法切入 RSA 的设计思路，现在，我们从它的实际效果：公钥加密，私钥解密来入手，尝试一步步分析它，了解它。\n我们首先面临的问题是，如果想要达到加解密的钥匙分开的效果，应当怎么做呢？\n先尝试使用数学语言抽象化描述一下这个问题：\n设加密函数为$f_1(m,e)$，m 为明文，e 为加密密钥，解密函数为$f_2(x,d)$，x 为密文，d 为解密密钥，那么，我们需要寻找函数$f_1$和$f_2$，使得：$m=f_2(f_1(m, e),d)$成立，经过函数$f_1$和$f_2$两次变换之后，我们需要能够把明文给还原回来。\n为了解决上面的问题，我们需要对两个数学知识有一定的了解，第一个是欧拉定理，第二个则是模算术。\n欧拉定理 $$ 若a,m均为正整数,且gcd(a,m)=1,则a^{\\varphi(m)}\\equiv 1 (\\mod m) $$ $gcd(a,m)$表示求数 a 和 m 的最大公因数，如果最大公因数为1，这两个数互质。\n其中$\\varphi(m)$是一个重要的数论函数：欧拉函数。$\\varphi(m)$表示小于等于m的正整数中与m互质的数的数目。显然，若 m 为素数，则$\\varphi(m)=m-1$。\n基本的模算术 如果 A 和 B 满足$A \\mod n=B\\mod n$，我们称之为 A 与 B 有同余关系，同余关系常常又表示成：$A\\equiv B (\\mod n)$。同余关系是一种等价关系。\n模的含义可以换算为普通乘式： $$ A\\mod B=C \\rightarrow A=kB+C $$ 基本的模加法和模乘法、模幂运算规则如下： $$ \\displaylines{ (A + B) \\mod C = (A \\mod C + B \\mod C) \\mod C \\\\ (A * B) \\mod C = ((A \\mod C) * (B \\mod C)) \\mod C \\\\ (A^B)\\mod C = (A\\mod C)^B \\mod C \\\\ } $$\n了解了模幂的规则，其实我们很快就能发现函数$f(a,x)=a^x\\mod m$很有趣，因为存在$f(f(a,e),d)=f(a,ed)$，即$(a^e \\mod m)^d \\mod m = a^{ed} \\mod m$成立，而$a^{ed} \\mod m$与$a^{\\varphi(m)}\\equiv 1 (\\mod m)$之间的相似度又不禁令我们遐想联翩。实际上，欧拉定理再变通一下，我们就能得到$a^{\\varphi(m)+1}\\mod m=a$，其中$a \u003c m$。那么，要是$ed=\\varphi(m)+1$的话，不就有$a^{ed} \\mod m=a^{\\varphi(m)+1}\\mod m=a$了吗？！那么，我们现在这样来描述我们的加解密函数$f_1$和$f_2$，令$f_1=f_2=a^x\\mod m$，其中 a 为明文，选择一个 $m$，计算 $\\varphi(m)$，公钥和私钥的策略是，然后选择一个 $e$ 并根据 $ed=\\varphi(m)+1$ 计算 $d$。\n经过上面的简单思考，我们来解决一些随之而来的问题。\n首先，我们为了得到 $a^{\\varphi(m)+1}\\mod m=a$，实际上弱化了欧拉定理，要求底数 $a \u003c m$。不过这并不是什么大问题，底数 a 代表的明文如果实在太长，我们把它分割一下，让它小于m就行了。\n其次，欧拉定理还要求底数 a 和模 m 互质（$gcd(a,m)=1$），这是一个比较严苛的要求。幸运的是，即使明文 a 与 m 不互质，我们也可以证明我们的加密、解密函数仍然有效，稍后将给出证明。\n另外，在实现上仍有诸多疑问：一个数的幂的结果增长得特别快，计算 $a^{ed}$ 是否很容易超出编程语言中整型变量的范围呢？如何根据 $n$ 确定$\\varphi(n)$？\n快速模幂 我们先来解决计算$a^{ed}\\mod n$的问题。\n例如，要求计算$2^{256}\\mod 7$。显然，先计算出$2^{256}$不是什么明智的选择。根据模算术的基本规则，我们可以得到： $$ 2^{256}\\mod 7=(2^{128}\\mod 7*2^{128}\\mod7)\\mod7 $$ 如何求$2^{128}\\mod 7$呢？答案是去求解$2^{64}\\mod 7$，这样循环递归下去，我们可以凭借$2\\mod 7$的结果计算$2^{256}\\mod 7$！这是基于分治思想得出的算法。\n不过，如果幂不能被2整除呢？例如求$3^{117}\\mod 7$。这时，关键在于如何对整数117按照2的若干次幂进行划分，其实117的二进制表示本身就是一种天然划分。把117表示成二进制：$117=(1110101)_2$，$3^{117}=3^{2^0+2^{2}+2^{4}+2^{5}+2^{6}}=3^1*3^4*3^{16}*3^{32}*3^{64}$\n我们可以使用动态规划的思想，自底向上进行迭代来求解这个问题。\n分析递推式，有$2^k\\mod n=(2^{k-1}\\mod n)^2\\mod n$，事实上动态规划表内第 k 项只和第 k-1 项有关，我们可以省略一个完整的动态规划表，只保留 k-1 项。\npublic static int fastModularExponentiation(int base, int power, int p) { // 缓存k-1项 int i = base % p; int result = 1; while (power \u0026gt; 0) { if ((power \u0026amp; 1) == 1) { result = (result * i) % p; } i = (i * i) % p; power = power \u0026gt;\u0026gt; 1; } return result; } 如何产生n与如何计算$\\varphi(n)$ 因为我们选定了$f(m,e)=m^e\\mod n$来进行加密运算，那么公钥 e 和模 n 都需要公开，其他人才可以进行加密。$n$ 被公开则触及一个核心的问题：既然 $n$ 被公开，$\\varphi(n)$ 不是很容易被计算出来吗？又有 $ed=\\varphi(n)+1$，那么密钥 $d$ 不是很容易确定吗？这样还存在保密性吗？\n首先，对于一个合数而言，欧拉函数$\\varphi(n)$的值其实不那么容易被计算出来，因为没有有效的算法来计算甚至估算这个函数的值，我们只能暴力地从1到$n-1$，一个个去尝试它是否与 n 互质。问题随之而来，如果公开的模 n 复杂到别人无法暴力破解$\\varphi(n)$，那么我们又凭什么能够快速算出$\\varphi(n)$呢？算法又需要这个值来生成公钥和私钥。\n下面的这个定理完美解决了上述问题 $$ 若p和q都是素数，n=pq，那么\\varphi(n)=\\varphi(p)\\varphi(q) $$ 以上定理不作证明，我们使用这个定理，轻易就能得出$\\varphi(n)=(p-1)(q-1)$，也就是说，只要找到 n 的两个素数因子，我们就能确定$\\varphi(n)$，以这种思路来计算$\\varphi(n)$的可行性基本上是……0。是的，当 n 相当大的时候，找出两个素数因子简直难如登天。我们不是采用这种方法来计算$\\varphi(n)$，而是以这种思路来生成 $n$，从而不费吹灰之力得到$\\varphi(n)$：先选择两个大素数 p 和 q，然后计算 n=pq，$\\varphi(n)$自然等于$(p-1)(q-1)$，而公开的公钥对{e，n}中，别人只拿到了 n，想计算出$\\varphi(n)、p、q$反而相当困难。\n公钥e和私钥d的生成 既然我们已经调整了 n 的生成过程，其实公钥 e 和私钥 d 的生成过程我们也需要调整了。因为要求$ed=\\varphi(n)+1$不一定能得到满足，我们不能保证$\\varphi(n)+1$一定是一个合数，为此不停生成 n 显得有点本末倒置，我们希望能够得到一个更简洁的公钥私钥生成过程。\n$ed=\\varphi(n)+1$不一定成立？没关系，我们可以加入一个系数 k，构造$ed=k*\\varphi(n)+1$，k 为整数，当 k=1 时不成立也不要紧，只要有一个 k 能使得上述式子成立就行了。加上 k 之后，$ed$ 的含义并没有改变，因为$a^{\\varphi(n)}\\equiv 1 (\\mod n)$成立意味着$a^{k\\varphi(n)+1}\\equiv a (\\mod n)$也成立。\n先不讨论是否真的存在一个这样的 k，我们先来化简一下这个式子。还记得模与普通算式的转换吗？ $$ ed=k*\\varphi(n)+1\\rightarrow ed\\equiv 1(\\mod \\varphi(n)) $$ 然后，上述式子还可以写为 $$ d= e^{-1}\\mod \\varphi(n) $$ d 称之为 e 的模逆元，不过 e 的模逆元的意思可不是 e 的倒数求模，而是求一个数 d 能使得 e 与 d 的乘积与1同余。\n经过修改，我们暂时把公钥 e 和私钥 d 的生成过程描述如下： $$ 选择一个公钥e，计算私钥d= e^{-1}\\mod \\varphi(n)。 $$ 现在我们再来思考这个问题：是否存在一个整数 k，使得$ed=k*\\varphi(n)+1$成立呢？如果不成立，私钥 d 就不存在了。需要什么前提条件使得 k 存在吗？\n解决这个问题需要引入线性同余方程的概念。 $$ 在数论中，形如ax\\equiv b(\\mod n)的形式的方程称之为线性同余方程 $$ 此方程有解当且仅当 $b$ 能够被 $a$ 与 $n$ 的最大公因数整除。该性质的详细证明忽略。由该性质得到下面的引理： $$ 设a和b不全为0，则存在整数x，y，使得gcd (a,b)=ax+by $$ 我们拿出方程式$ed\\equiv 1(\\mod \\varphi(n))$对比上面的同余方程一般式，就能发现，只要 e 和 $\\varphi(n)$ 的最大公因数为1(它们互质)，那么方程的解就存在，也就是私钥 d 存在。\n既然证明了私钥 d 是存在的，剩下的问题则是如何计算它。计算私钥 d 的核心思想是扩展欧几里得算法。\n提到欧几里得算法（GCD），相比各位不会陌生，这是一个求数 A 和 B 的最大公因数的高效算法，我们有 $$ gcd(a,b)=gcd(b, a\\mod b) $$ 该算法正确性的证明不作讨论，我们仅关注怎么使用它来解决同余方程，计算出我们想要的私钥d。\n下面是扩展欧几里得算法的思路： $$ \\begin{aligned} gcd(a,n)\u0026=ax_1+ny_1 \\\\ gcd(n, a \\% n) \u0026= nx_2+(a\\% n)y_2\\\\ \u0026=nx_2+(a-a/n*n)*y_2 \\\\ \u0026= nx_2+ay_2-a/n*n*y_2 \\\\ \u0026=ay_2+n(x_2-a/n*y_2) \\\\ \\end{aligned} $$ 因为$gcd(a,n)=gcd(n, a \\mod n)$，所以$x_1=y_2,y_1=x_2-a/n*y_2$，我们得到了计算 a 与 n 的最大公因数的过程中 x 和 y 的递推公式，据此可以写出算法的简单实现代码。\npublic static int x = 0; public static int y = 0; /** * 计算ax+ny=1的特解 */ public static int gcd(int a, int n) { if (n == 0) { x = 1; y = 0; return a; } else if (a == 0) { x = 0; y = 1; return n; } else { int c = gcd(n, a % n); int tmp = x; x = y; y = tmp - a / n * y; return c; } } 上面的静态变量 x 就是我们想要的私钥 d。现在，生成私钥 d 已经不是难题了。\nRSA算法全过程 我们已经差不多把 RSA 算法的全过程都解释了一遍，现在来浏览一下真正的 RSA 算法全过程吧。\n密钥生成 选择大素数 p 与 q，计算$n=pq$，$\\varphi(n)=(p-1)(q-1)$，然后丢弃 p 和 q，不保留。 在$1 \u003c e \u003c \\varphi(n)$的范围内选择整数公钥 e，使得$gcd(e,\\varphi(n))=1$（若 $e$ 和 $\\varphi(n)$ 不互质，则不存在私钥 $d$，这点上面已经证明过了）。 计算私钥 d，$d=e^{-1}\\mod \\varphi(n)$。 加密过程 发送方获得公钥对{e,n} 把明文 $m$ 分解为小于 n 的若干块 计算密文$C=m^e\\mod n$ 解密过程 接收方提前内置密钥对{d,n} 对密文解密$m=C^d\\mod n$ 尾声：RSA算法正确性证明 回到我们最开始先忽略的那一个问题，既然欧拉定理要求底数 a 与模 n 互质，当明文 a 与模 n 不互质的时候，还能够完成加密并解密的任务吗？先给出结论，结论是只要 a 不是模 n 的倍数，RSA 算法就是正确的。既然我们要求了$a \u003c n$，那么 a 是 n 的倍数的可能性不复存在。\n以下是证明： $$ 设n=pq，a是某一个整数、gcd(a,n)\\neq 1 且a不能被n整除，试证明a\\equiv a^{k\\varphi(n)+1}(\\mod n) $$\n$$ \\displaylines{ 若a与n不互质，必有p|a(a能被p整除)或者q|a。设p|a成立，必有gcd(q,a)=1，否则n|a，不符合题设条件。\\\\同理设q|a成立也是一样的情况，不失一般性，设p|a成立。 由欧拉定理和\\varphi(n)=(p-1)(q-1)得到：\\\\ a^{\\varphi(n)}\\equiv 1(\\mod q) \\\\ a^{k\\varphi(n)}\\equiv 1(\\mod q) \\\\ 令m为整数,有\\\\ a^{k\\varphi(n)}=mq+1\\\\ a^{k\\varphi(n) + 1}=maq+a\\\\ 将a分解为a=xp \\\\ a^{k\\varphi(n) + 1}=mxpq+a=mxn+a\\\\ 则a^{k\\varphi(n) + 1}\\equiv a(\\mod n)成立 } $$\n","permalink":"https://usagisang.github.io/posts/rsa/","summary":"\u003cp\u003e不同于传统的对称加密算法体系，非对称公私钥密码系统中的加密密钥和解密密钥是相互分开的，加密密钥用于公开给别人加密，而只有持有解密密钥的人才能对信息进行解密。1976年诞生过不少非对称密码算法，但是 RSA 是其中最容易让人理解的。下文将尝试对 RSA 实现的具体流程进行解析。\u003c/p\u003e","title":"RSA"}]