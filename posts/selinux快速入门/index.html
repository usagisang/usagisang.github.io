<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SELinux快速入门 | Milky Way</title>
<meta name=keywords content><meta name=description content="
本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki

SELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。"><meta name=author content="kigumi"><link rel=canonical href=https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.227e982e31d4cea8d1002726fc22efb880675b366547a49d82cef2269a5ddc9c.css integrity="sha256-In6YLjHUzqjRACcm/CLvuIBnWzZlR6Sdgs7yJppd3Jw=" rel="preload stylesheet" as=style><link rel=icon href=https://usagisang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://usagisang.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://usagisang.github.io/favicon.ico><link rel=apple-touch-icon href=https://usagisang.github.io/favicon.ico><link rel=mask-icon href=https://usagisang.github.io/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><meta name=google-site-verification content="gZ_y5FZMr0xyqn2GYGweWkUiR91xeh6QD1rotAljnIQ"><script>document.addEventListener("DOMContentLoaded",()=>{var e,n=document.body.textContent;const t=document.querySelector(".main"),s=!0;if(s&&n.match(/(?:\$|\\begin\{.*?})/)){const n=setTimeout(()=>{t.classList.add("visible")},3e3);window.MathJax||(window.MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]],processEscapes:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code","annotation","annotation-xml"]},startup:{typeset:!1,pageReady:()=>MathJax.startup.defaultPageReady().then(()=>{MathJax.typeset(),t.classList.add("visible"),clearTimeout(n)}).catch(e=>{console.error("MathJax rendering failed:",e)})}}),e=document.createElement("script"),e.src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js",e.setAttribute("async",""),document.head.appendChild(e)}else t.classList.add("visible")})</script><meta property="og:url" content="https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="Milky Way"><meta property="og:title" content="SELinux快速入门"><meta property="og:description" content=" 本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki
SELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-27T00:00:00+00:00"><meta property="og:image" content="https://usagisang.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://usagisang.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="SELinux快速入门"><meta name=twitter:description content="
本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki

SELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://usagisang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SELinux快速入门","item":"https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SELinux快速入门","name":"SELinux快速入门","description":" 本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki\nSELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。\n","keywords":[],"articleBody":" 本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 wiki\nSELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。\n访问控制与SELinux上下文 为了说明 SELinux 到底是如何进行访问控制的，让我们来假设这样一个使用场景：现在有一名已登录的用户，向 shell 进程发送指令，要求 shell 进程读取一个文件 File。那么，SELinux 现在需要判断 shell 进程是否有权限读取文件 File。\nSELinux 进行判断的依据非常简单。首先，无论是进程还是文件，SELinux 都会维护它们的”标签“，比如说 shell 进程的”标签“是 user_t，而文件 File 的”标签“是 lib_t，然后根据它们两个的标签， SELinux 将在规则集合中寻找相应的条目，如果找到的条目为 allow，即允许访问，那么 SELinux 将放行此次访问，否则拒绝。\n这就是 SELinux 的工作原理：基于”标签“来查找匹配的规则。\n给”标签“打上双引号是因为这只是方便读者理解原理而使用的名字，它的正式称呼是 SELinux 上下文。另外，我们所述的 user_t 并不是完整的 SELinux 上下文。完整的 SELinux 上下文由以下3个部分组成（有时是4个部分）：\n第一部分是 SELinux 用户 其次是 SELinux 角色 接下来是 SELinux 类型 最后是可选部分，表示敏感度级别 比如说，一个文件的 SELinux 上下文可能会是这样的：system_u:object_r:lib_t:s0。system_u表示 SELinux 用户，object_r表示 SELinux 角色，lib_t是 SELinux 类型，最后的s0则表示敏感度级别。\n或许你已经注意到，SELinux 用户、角色、类别都有一个后缀，这只是一个命名惯例。在 SELinux 世界中，基本上可以认为，带有_u后缀的名字是在指代 SELinux 用户，带有_r后缀的名字是在指代 SELinux 角色，带有_t后缀的名字在指代 SELinux 类型。我们接下来讨论 SELinux 也会不时运用这些命名惯例，所以当你看到_t后缀的名字但没说明它是什么的时候，请不要惊讶。\n每个进程和文件都有各自的上下文，在启用了 SELinux 的系统上，如果想要查看文件或进程的 SELinux 上下文，请在调用相关命令时添加-Z参数，比如ls -Z可以显示文件的上下文，ps -Z可以显示进程的上下文。\nSELinux 使用每个字段来决定对访问的控制，我们将逐步介绍 SELinux 上下文中这些字段的具体作用。但实际上大多数规则都是围绕着 SELinux 类型来制定的，从这个角度出发，我们决定先介绍 SELinux 上下文中最重要的信息： SELinux 类型。\n类型强制规则 类型强制（Type Enforcement，简称TE）基于 SELinux 上下文中的 SELinux 类型。TE 模型是 SELinux 发挥作用的基石，构成了绝大多数 SELinux 策略。\nTE 模型规则的底层逻辑可以归结为三个单词组成的句子：\"Subject-Access-Object\"，即“主体-操作-客体”。\n在 SELinux 中，主体（Subject）指的是进程。操作（Access）指代的是一系列动作，比如 read、write、ioctl 等系统调用。客体（Object）指的是操作适用的系统资源，包括文件、进程、socket 等，客体是被动的，不会主动执行任何操作——当它主动执行任何操作时它就成为了主体。\n进程既可以成为主体，也可以作为客体，比如，一个进程向另一个进程发送终止信号时，进程就既是主体也是客体。\n规则底层逻辑的这三个要素体现在了具体的规则中。一个典型的 TE 规则的形式如下所示：\nkind source target:class permissions; kind——有几种选项，常用的是 allow、neverallow 和 dontaudit。allow 表示允许；neverallow 表示不允许；dontaudit 表示出现对应违规项后静默，不输出任何拒绝日志 source——规则的主体的类型。“谁在请求访问” target——客体的类型。“请求访问什么” class——类别。正在访问的客体（file、 socket、process 等）的类别 permissions——正在执行的操作（或一组操作）（例如，read、write） 一个实际的示例如下：\nallow user_t bin_t:file { read write }; 上面的规则的含义是：允许类型为 user_t 的进程，读取或写入，类型为 bin_t 而且类别（class）为 file 的客体。\n需要注意的是，由于主体和客体都拥有 SELinux 类型，为了方便区分这两者，与 SELinux 相关的文档中常常把赋予进程的 SELinux 类型称作域（domain），客体的则仍称作“类型”，我们也会延续这种习惯。\n客体需要区分类别，因为不同的系统资源所支持的操作集不同，比如，主体可以向进程但无法向文件发送信号。从这个角度来看，客体是由类型(bin_t)和类别(file)共同组成的。\n如果想查询客体有哪些类别，请执行ls /sys/fs/selinux/class\n如果想知道某一个类别的操作集，比如说 file 类别的操作集，请执行ls /sys/fs/selinux/class/file/perms/\n属性 SELinux 中常常包含上千种 SELinux 类型，因此，经常会遇到大部分主体对某个客体的权限完全一样的情况，如果规则只接受单个主体到单个客体的映射，会导致大量对同一个客体的重复定义。比如说，我们有三个类型对同一个客体的访问权限一致：\nallow trusted_app app_data_file:file { read write }; allow untrusted_app app_data_file:file { read write }; allow isolated_app app_data_file:file { read write }; 为了解决这种繁琐的重复定义问题，SELinux 支持对访问控制规则进行分组，这项特性被称为属性（attributes）。\n我们可以将域或类型分配到某一个属性，在定义访问控制规则时，可以利用属性进行定义，属性可以用在主体级别、对象级别或同时用于两者。\n属性定义以及将属性用于规则的示例如下：\n# Associate the attribute appdomain with the type untrusted_app. typeattribute untrusted_app appdomain; # Associate the attribute appdomain with the type isolated_app. typeattribute isolated_app appdomain; allow appdomain app_data_file:file { read write }; 至此，我们总结一下前面的内容。SELinux 绝大部分规则都是基于类型的规则。根据这些类型，SELinux 将授予或拒绝进程对文件的相应操作。多数情况下，在 SELinux 那冗长的上下文中我们只需要关注类型字段，而且由于完整的上下文真的太长了，下文也常常用 SELinux 类型来指代 SELinux 上下文这个概念。\n我们也可以在定义一个类型的语句中顺便定义这个类型所关联的属性。类型定义语法如下：\ntype 类型名 [alias { 别名1, 别名2 }] [, 属性1];\n中括号不是语法内容，而是表示这部分内容可写可不写。alias 表示别名部分，可以为类型赋予其他多个别名。逗号后接的内容视为属性部分，同样也可以关联多个属性。比如，下述声明语句：\ntype httpd_t, file_type, domain; 既定义了一个 SELinux 类型 httpd_t，也将 httpd_t 这个 SELinux 类型关联到属性 file_type 和 domain，它等价于下述语句：\ntype httpd_t; typeattribute httpd_t file_type, domain; 上下文继承 默认情况下，若 SELinux 中没有其他指定的策略，则新的进程和文件的 SELinux 类型是从其父级继承而来的。比如说：\n以foo_t上下文运行的进程 fork 新的子进程时，此进程的上下文也为foo_t 在上下文为bar_t的目录中创建的文件或目录也将获得bar_t上下文 如同所有的进程的源头都是 init 进程一样，追溯 SELinux 的上下文继承体系，也有一个所谓的根上下文。进程和文件的根上下文都由相应的 SELinux 策略定义。一般来说，在 Linux 中文件的根上下文是root_t，进程的根上下文是kernel_t。\n域转换 进程如何进入特定的上下文\n既然进程有根上下文，那么 SELinux 势必要支持域转换，否则所有的进程只会拥有同一个上下文。进程可以通过三种方式进行域转换：\n通过 type_transition 语句自动转换 使用 libselinux 中的 setexeccon() 使用 libselinux 中的 setcon() 第一种是为不支持 SELinux （不使用 libselinux ）且对 SELinux 一无所知的应用准备的；后两种则需要引入 libselinux 。setexeccon()函数可以指定下一次调用exec()后新进程的上下文，而setcon()最为特殊，它可以直接改变当前进程的上下文。\n无论进程采用哪一种方式，SELinux 并不会自动许可域转换，所以我们在确定好哪些域要转换后，还必须编写相应的 allow 规则来放行这些转换。\n虽然从系统的角度来看，exec()并不会诞生新进程，但我们姑且把一个进程替换自身代码段的行为称之“创建”了新进程。\ntype_transition语句 这是最常用的方式。我们知道，默认情况下，在新旧进程之间，域将原封不动地继承，但type_transition定义可以改变这种默认行为。一旦满足条件，SELinux 将根据type_transition语句决定新进程的域，域转换自动发生。\ntype_transition定义的示例如下：\ntype_transition init_t initrc_exec_t : process initrc_t; 它的含义是：当 init_t 进程执行（通过exec）上下文为 initrc_exec_t 的文件时，生成的进程应在 initrc_t 上下文中运行。在满足后面我们会提到的条件后，SELinux 将自动执行域转换。\n上面的示例展示了定义域转换所需的三个要素：原来的域，可执行文件的类型，新的域。\n采用这种方式定义域转换不存在侵入性，因而非常适合那些不方便引入 libselinux 库的程序。即使应用程序引入了 libselinux，也经常依赖type_transition语句进行自动域转换。\n使用 libselinux 中的 setexeccon() 支持 SELinux 的应用可以使用 libselinux 中的 setexeccon()，这个函数将设置用于下一个exec()调用的上下文。另外，应用必须具有 setexec 权限才能使用这个 API，例如：\nallow crond_t self:process setexec; self:process是一种特殊的客体写法，但应该不难理解，它指明客体就是主体的这个进程。\n使用 libselinux 中的 setcon() 应用还可以使用setcon()函数直接切换当前进程的上下文。和setexeccon()一样，进程执行setcon()也需要一个特殊的 SELinux 权限setcurrent。\nallow crond_t self:process setcurrent; 使用这个 API 有一些额外的限制，比如，如果应用使用多线程，那么必须在创建任何子线程之前执行setcon()，这种情况下后续创建的所有子线程都将继承新的上下文。但是如果调用setcon()时同一进程中还有其他线程在运行，此调用将失败。\n域转换许可规则 如果域转换最终需要执行exec()才生效（对应第一种和第二种域转换方式），那么，我们就需要添加三条 allow 规则来许可域转换。这些策略用来满足以下三个条件：\n原始域对文件具有执行权限 文件上下文本身被标识为目标域的入口点（entrypoint） 允许原始域转换到目标域 我们以initrc_t进程通过执行sshd_exec_t文件来转换到sshd_t这个域为例。\n首先，exec()调用需要指定某个可执行文件，这当然需要授予一个允许进程执行文件的权限。比如，允许initrc_t进程执行sshd_exec_t文件：\nallow initrc_t sshd_exec_t : file { read getattr execute open } ; 然后，SELinux 并不知道sshd_exec_t文件和sshd_t域之间到底有什么关系，因此我们需要添加一条规则来告诉 SELinux，执行sshd_exec_t文件时，可以将域转换到sshd_t。这种特性被我们称之为 entrypoint，定义的方式为，在通常的 allow 规则中，主体sshd_t对客体sshd_exec_t的操作集中添加 entrypoint，示例如下：\nallow sshd_t sshd_exec_t:file { ioctl read getattr lock execute execute_no_trans open entrypoint }; 由于“主体-操作-客体”的 SELinux 底层逻辑的限制，我们没办法以客体为主语，因此 entrypoint 的 allow 规则显得比较抽象，遇到 entrypoint 时，试着反过来理解 allow 规则，逻辑会更顺畅。\n最后，我们还需要告诉 SELinux，允许从initrc_t域转换到sshd_t域。\nallow initrc_t sshd_t:process transition; 为什么我们最后需要定义一个 allow 规则来允许一个域向另一个域转换？这是因为一个文件可以成为多个域的 entrypoint，比如说，sshd_exec_t同时还是xm_ssh_t域和ssh_t域的 entrypoint。因此，SELinux 不允许一个域获得一个文件的执行权限就可以根据 entrypoint 定义转换到其他所有域， SELinux 要求明确指出，从哪个域到哪个域的转换才是被允许的。\n如果应用使用setcon()直接切换本进程的上下文，那么，我们需要添加对目标上下文的dyntransition操作的 allow 规则，表明一个上下文可以“动态”切换到目标上下文。\nallow adbd su:process dyntransition; 这是 Android 中的 SELinux 规则的一个例子，它表明在 adbd 域中的进程可以动态切换到 su 域中。\n客体的类型转换 和进程间的域转换类似，我们也可以为客体定义相应的类型转换语句，让 SELinux 在满足相应条件后自动执行类型转换。例如，现在有一个域为ext_gateway_t的进程，希望在类型为in_queue_t的文件夹内保存文件时，该文件的类型不继承父目录的类型，而是使用另一个类型in_file_t。示例的定义语句如下：\ntype_transition | source_domain | target_type : object ----------------▼---------------▼--------------▼----------------- type_transition ext_gateway_t in_queue_t : file in_file_t; 这个 type_transition 语句的含义是，当在ext_gateway_t域（source_domain） 中运行的进程想要在类型为in_queue_t的目录中创建file对象时，如果策略允许，则应将该文件重新标记为in_file_t\n为了能够创建文件，我们还需要在 SELinux 中添加相应的 allow 规则。\n源域需要有权限将file添加到in_queue_t目录中\nallow ext_gateway_t in_queue_t:dir { write search add_name }; 源域需要有创建in_file_t文件的权限\nallow ext_gateway_t in_file_t:file { write create getattr }; SELinux上下文与其他安全模型 我们已经围绕着 TE 模型及其规则介绍了许多内容，相信你已经体会到它的强大之处。靠着 TE 模型，SELinux 似乎已经可以工作得很好，但人类的需求总是复杂多变。不同于 TE 模型的设计思路，人类经常以用户、角色、项目等比较抽象的概念来管理权限。SELinux 为这些希望使用不同安全模型的需求提供了直接的支持，实际上，安全上下文中我们尚未介绍到的那些字段全都是用来支持其他安全模型的。\nSELinux 角色与 SELinux 用户直接支持了 RBAC （Role-Based Access Control，基于角色的访问控制）模型；SELinux 敏感度级别则支持了 MCS（Multi-Level Security）和 MLS（Multi-Category Security）模型。\n这些名词你可能很熟悉也可能很陌生，我们稍后会解释这些名词的含义。但重要的是要理解，这些安全模型都是建立在 TE 模型之上的额外的“高级”模型，只有通过 SELinux 类型的检查后，SELinux 上下文的其他部分才会继续发挥作用。SELinux 提供这些功能只是为了便于人类进行管理，但不使用它们，SELinux 也能正常运行。\n角色与RBAC模型 首先，需要说明的一点是，SELinux 角色只针对主体，对客体（文件）来说没有意义，因此，如果你使用ls -Z来查看文件的角色，你会发现它们清一色都是object_r。这个字符串只是因 SELinux 上下文不能缺少角色字段而存在的一个占位符，将进程更改为以 object_r 角色运行或尝试为文件分配不同的角色始终会被内核拒绝。\n那么，SELinux 中的角色与主体的访问控制之间有什么联系呢？为了回答这个问题，我们首先捋清楚 Linux 用户、SELinux 用户、SELinux 角色和域（SELinux 类型）之间的关系，如下图所示。\nSELinux 用户与 Linux 用户不同，它是一个独立的概念。在 SELinux 中，每个 Linux 用户都必须映射到且只能映射到一个 SELinux 用户，但支持多个 Linux 用户映射到同一个 SELinux 用户上；SELinux 用户与 SELinux 角色则是一种多对多的关系，每个 SELinux 用户都可以持有多个角色；而对于每一个 SELinux 角色来说，它们可以关联到不同的域。\n这种关联是在规定 SELinux 角色可以进入哪些域（上下文）。当然，用户控制的进程需要先通过域转换这一关， SELinux 角色的限制则在于，即使被允许转换到目标域，如果该域未附加到相应角色，转换也会失败。\n我们举一个例子说明这一点：\n假设一名开发人员试图从命令行启动 mysql 守护进程。我们知道，shell 进程被允许执行mysqld_exec_t文件并进行域转换，新的守护进程的上下文应该是mysqld_t，但不巧的是，这名人员的角色是user_r而不是数据管理员dbadm_r，mysqld_t这个域只与数据管理员关联，而没有关联到user_r这个角色上，因此本次操作将被 SELinux 阻止。\n总的来说，角色进一步限制了用户能够与哪些进程打交道。\nRBAC模型 SELinux 角色可以用于实现 RBAC （Role-Based Access Control，基于角色的访问控制），RBAC 是一种抽象的访问控制模型， 核心理念是：\n权限始终通过角色授予，不直接分配给用户 必须明确授予用户相应角色，没有角色，就没有权限 MLS与MCS 我们介绍 SELinux 上下文中的最后那一部分：敏感度级别。其实在之前的示例中，我们没有完整展现这一部分的内容，实际上敏感度级别分为两个维度的内容，分别是秘密等级和类别集。比如说下面的上下文：\nuser_u:user_r:user_t:s0:c0,c1\ns0表示秘密等级，c0,c1表示类别集是0和1。\n秘密等级可以看作对现实中的秘密等级的抽象实现。如果你了解《中华人民共和国保守国家秘密法》，应该知道所谓的“国家秘密”分为三种：绝密、机密和秘密。体现到 SELinux 上，我们可以规定，s3 表示绝密，s2 表示机密，s1 表示秘密，s0 表示公开。这样一来，即使 SELinux 类型允许进程访问高等级秘密文件，但由于秘密等级不匹配，进程依旧会读取失败。比如说，对于 s2 的进程来说，它可以读取 s2 或更低级别的文件，但无法读取更高级别比如 s3 文件。秘密等级实现了所谓的多级安全性（Multi-Level Security，MLS）。\n结合上面的秘密等级，类别集可以理解为，我们有两个秘密等级相同的项目，比如有两个 s3 绝密项目，虽然它们秘密等级相同，我们也不希望这两个项目之间的人员（进程）互相查看对方的资料（文件），因此，我们使用类别来区分这两个项目。比如说，项目 X 被划分到c0，项目 Y 被划分到c1，那么，持有s3:c0的进程可以访问项目 X 的文件，但无法访问项目 Y 的文件了。SELinux 使用类别集，实现了所谓的多类别安全性（Multi-Category Security，MCS）。\n最后，我们说明一下这部分上下文的一些特殊形式。对于秘密等级，可以使用-符号来表示范围，比如s0-s2就表示从 s0 到 s2 的等级。对于类别集，可以使用.符号来表示范围，比如c0.c15表示从类别集 c0 到 c15。\n拒绝日志 本节简单介绍一下 SELinux 拒绝日志里面包含了什么内容，至于如何根据拒绝日志添加 SELinux 策略，这是一个比较复杂的问题，本节不会讨论。\n在查看拒绝信息之前，我们需要注意以下几点：\n在日志中发现的拒绝并非都是大问题。有些拒绝只是表面上发生了，但不会影响应用程序的行为。这通常是由于应用程序开发不当（例如未正确关闭文件描述符）或由于高级库函数（应用程序仅使用了一小部分功能）造成的。 拒绝一出现就会被记录下来。这意味着在日志中我们将看到大量的拒绝，尽管许多拒绝彼此相关（一个拒绝导致另一个拒绝），但大部分拒绝与正在调查的问题无关。 如果连续出现太多拒绝，Linux 内核可能会抑制这些拒绝。因此可能看不到 SELinux 报告的所有内容。 dontaudit会抑制拒绝日志的输出，因此，不要太依赖日志，必要的时候请 review 相应的 SELinux 策略。 拒绝日志的示例如下：\navc: denied { open } for pid=1003 comm=”mediaserver” path=\"/dev/kgsl-3d0” dev=\"tmpfs\" scontext=u:r:mediaserver:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=1 下表给出了每一部分日志的解释\n日志 描述 avc: 告知用户这是哪种类型的日志条目。在本例中，这是 AVC 日志条目。 denied SELinux 最终的反应，可以是 denied 或 granted。注意，如果 SELinux 处于宽容模式，尽管实际没有拒绝，在日志中依然会被记录 denied { open } 试图执行的操作，有时会包含一组操作，如{ read write } pid=1003 进程 pid comm=”mediaserver” 进程命令（不带参数，且限制为 15 个字符），帮助用户在进程已经死亡的情况下识别该进程是什么 path= 目标的绝对路径。注意，此字段很大程度上取决于目标类别，因此可能是path=、name=、capacity=、src= 等等 dev=“tmpfs” 目标所在的设备 scontext= 进程的上下文（域） tcontext= 目标资源（本例中为文件）的上下文 tclass= 目标的类别 permissive=1 表示是否允许此次操作，为1表示允许 本文的SELinux策略语法 SELinux 有两套策略语言，分别是 CIL 策略语言和内核策略语言。本文所展示的 SELinux 策略代码均基于内核策略语言。\n","wordCount":"7782","inLanguage":"zh","image":"https://usagisang.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-11-27T00:00:00Z","dateModified":"2024-11-27T00:00:00Z","author":{"@type":"Person","name":"kigumi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://usagisang.github.io/posts/selinux%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},"publisher":{"@type":"Organization","name":"Milky Way","logo":{"@type":"ImageObject","url":"https://usagisang.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://usagisang.github.io/ accesskey=h title="Milky Way (Alt + H)"><img src=https://usagisang.github.io/favicon.ico alt aria-label=logo height=35>Milky Way</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://usagisang.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://usagisang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">SELinux快速入门</h1><div class=post-meta><span title='2024-11-27 00:00:00 +0000 UTC'>2024-11-27</span>&nbsp;·&nbsp;16 分钟&nbsp;·&nbsp;kigumi</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6%e4%b8%8eselinux%e4%b8%8a%e4%b8%8b%e6%96%87 aria-label=访问控制与SELinux上下文>访问控制与SELinux上下文</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e5%bc%ba%e5%88%b6%e8%a7%84%e5%88%99 aria-label=类型强制规则>类型强制规则</a><ul><li><a href=#%e5%b1%9e%e6%80%a7 aria-label=属性>属性</a></li></ul></li><li><a href=#%e4%b8%8a%e4%b8%8b%e6%96%87%e7%bb%a7%e6%89%bf aria-label=上下文继承>上下文继承</a></li><li><a href=#%e5%9f%9f%e8%bd%ac%e6%8d%a2 aria-label=域转换>域转换</a><ul><li><a href=#type_transition%e8%af%ad%e5%8f%a5 aria-label=type_transition语句>type_transition语句</a></li><li><a href=#%e4%bd%bf%e7%94%a8-libselinux-%e4%b8%ad%e7%9a%84-setexeccon aria-label="使用 libselinux 中的 setexeccon()">使用 libselinux 中的 setexeccon()</a></li><li><a href=#%e4%bd%bf%e7%94%a8-libselinux-%e4%b8%ad%e7%9a%84-setcon aria-label="使用 libselinux 中的 setcon()">使用 libselinux 中的 setcon()</a></li><li><a href=#%e5%9f%9f%e8%bd%ac%e6%8d%a2%e8%ae%b8%e5%8f%af%e8%a7%84%e5%88%99 aria-label=域转换许可规则>域转换许可规则</a></li></ul></li><li><a href=#%e5%ae%a2%e4%bd%93%e7%9a%84%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label=客体的类型转换>客体的类型转换</a></li><li><a href=#selinux%e4%b8%8a%e4%b8%8b%e6%96%87%e4%b8%8e%e5%85%b6%e4%bb%96%e5%ae%89%e5%85%a8%e6%a8%a1%e5%9e%8b aria-label=SELinux上下文与其他安全模型>SELinux上下文与其他安全模型</a></li><li><a href=#%e8%a7%92%e8%89%b2%e4%b8%8erbac%e6%a8%a1%e5%9e%8b aria-label=角色与RBAC模型>角色与RBAC模型</a><ul><li><a href=#rbac%e6%a8%a1%e5%9e%8b aria-label=RBAC模型>RBAC模型</a></li></ul></li><li><a href=#mls%e4%b8%8emcs aria-label=MLS与MCS>MLS与MCS</a></li><li><a href=#%e6%8b%92%e7%bb%9d%e6%97%a5%e5%bf%97 aria-label=拒绝日志>拒绝日志</a></li><li><a href=#%e6%9c%ac%e6%96%87%e7%9a%84selinux%e7%ad%96%e7%95%a5%e8%af%ad%e6%b3%95 aria-label=本文的SELinux策略语法>本文的SELinux策略语法</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>本文大量参考了 Gentoo Linux 文档中与 SELinux 相关的 <a href=https://wiki.gentoo.org/wiki/SELinux>wiki</a></p></blockquote><p>SELinux 安全子系统是对基于 UNIX 权限位的 Linux 常规访问控制的补充，不同于常规访问控制，SELinux 提供的访问控制更加安全但同时也更加难以维护。SELinux 灵活且复杂，但它的工作原理其实很简单，我们将逐步深入，介绍 SELinux 支持的各种功能。</p><h2 id=访问控制与selinux上下文>访问控制与SELinux上下文<a hidden class=anchor aria-hidden=true href=#访问控制与selinux上下文>#</a></h2><p>为了说明 SELinux 到底是如何进行访问控制的，让我们来假设这样一个使用场景：现在有一名已登录的用户，向 shell 进程发送指令，要求 shell 进程读取一个文件 File。那么，SELinux 现在需要判断 shell 进程是否有权限读取文件 File。</p><p>SELinux 进行判断的依据非常简单。首先，无论是进程还是文件，SELinux 都会维护它们的”标签“，比如说 shell 进程的”标签“是 user_t，而文件 File 的”标签“是 lib_t，然后根据它们两个的标签， SELinux 将在规则集合中寻找相应的条目，如果找到的条目为 allow，即允许访问，那么 SELinux 将放行此次访问，否则拒绝。</p><p>这就是 SELinux 的工作原理：基于”标签“来查找匹配的规则。</p><p>给”标签“打上双引号是因为这只是方便读者理解原理而使用的名字，它的正式称呼是 <strong>SELinux 上下文</strong>。另外，我们所述的 user_t 并不是完整的 SELinux 上下文。完整的 SELinux 上下文由以下3个部分组成（有时是4个部分）：</p><ol><li>第一部分是 SELinux 用户</li><li>其次是 SELinux 角色</li><li>接下来是 SELinux 类型</li><li>最后是可选部分，表示敏感度级别</li></ol><p>比如说，一个文件的 SELinux 上下文可能会是这样的：<code>system_u:object_r:lib_t:s0</code>。<code>system_u</code>表示 SELinux 用户，<code>object_r</code>表示 SELinux 角色，<code>lib_t</code>是 SELinux 类型，最后的<code>s0</code>则表示敏感度级别。</p><p><img loading=lazy src=https://wiki.gentoo.org/images/6/69/SELinux_context.png></p><p>或许你已经注意到，SELinux 用户、角色、类别都有一个后缀，这只是一个命名惯例。在 SELinux 世界中，基本上可以认为，带有<code>_u</code>后缀的名字是在指代 SELinux 用户，带有<code>_r</code>后缀的名字是在指代 SELinux 角色，带有<code>_t</code>后缀的名字在指代 SELinux 类型。我们接下来讨论 SELinux 也会不时运用这些命名惯例，所以当你看到<code>_t</code>后缀的名字但没说明它是什么的时候，请不要惊讶。</p><p>每个进程和文件都有各自的上下文，在启用了 SELinux 的系统上，如果想要查看文件或进程的 SELinux 上下文，请在调用相关命令时添加<code>-Z</code>参数，比如<code>ls -Z</code>可以显示文件的上下文，<code>ps -Z</code>可以显示进程的上下文。</p><p>SELinux 使用每个字段来决定对访问的控制，我们将逐步介绍 SELinux 上下文中这些字段的具体作用。但实际上大多数规则都是围绕着 SELinux 类型来制定的，从这个角度出发，我们决定先介绍 SELinux 上下文中最重要的信息： SELinux 类型。</p><h2 id=类型强制规则>类型强制规则<a hidden class=anchor aria-hidden=true href=#类型强制规则>#</a></h2><p>类型强制（Type Enforcement，简称TE）基于 SELinux 上下文中的 SELinux 类型。TE 模型是 SELinux 发挥作用的基石，构成了绝大多数 SELinux 策略。</p><p>TE 模型规则的底层逻辑可以归结为三个单词组成的句子："<strong>Subject-Access-Object</strong>"，即“主体-操作-客体”。</p><p>在 SELinux 中，主体（Subject）指的是进程。操作（Access）指代的是一系列动作，比如 read、write、ioctl 等系统调用。客体（Object）指的是操作适用的系统资源，包括文件、进程、socket 等，客体是被动的，不会主动执行任何操作——当它主动执行任何操作时它就成为了主体。</p><p>进程既可以成为主体，也可以作为客体，比如，一个进程向另一个进程发送终止信号时，进程就既是主体也是客体。</p><p>规则底层逻辑的这三个要素体现在了具体的规则中。一个典型的 TE 规则的形式如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>kind source target:class permissions;
</span></span></code></pre></div><ul><li>kind——有几种选项，常用的是 allow、neverallow 和 dontaudit。allow 表示允许；neverallow 表示不允许；dontaudit 表示出现对应违规项后静默，不输出任何拒绝日志</li><li>source——规则的主体的类型。“谁在请求访问”</li><li>target——客体的类型。“请求访问什么”</li><li>class——类别。正在访问的客体（file、 socket、process 等）的类别</li><li>permissions——正在执行的操作（或一组操作）（例如，read、write）</li></ul><p>一个实际的示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow user_t bin_t:file { read write };
</span></span></code></pre></div><p>上面的规则的含义是：允许类型为 user_t 的进程，读取或写入，类型为 bin_t 而且类别（class）为 file 的客体。</p><p>需要注意的是，由于主体和客体都拥有 SELinux 类型，为了方便区分这两者，与 SELinux 相关的文档中常常把赋予进程的 SELinux 类型称作域（domain），客体的则仍称作“类型”，我们也会延续这种习惯。</p><p>客体需要区分类别，因为不同的系统资源所支持的操作集不同，比如，主体可以向进程但无法向文件发送信号。从这个角度来看，客体是由类型(bin_t)和类别(file)共同组成的。</p><blockquote><p>如果想查询客体有哪些类别，请执行<code>ls /sys/fs/selinux/class</code></p><p>如果想知道某一个类别的操作集，比如说 file 类别的操作集，请执行<code>ls /sys/fs/selinux/class/file/perms/</code></p></blockquote><h3 id=属性>属性<a hidden class=anchor aria-hidden=true href=#属性>#</a></h3><p>SELinux 中常常包含上千种 SELinux 类型，因此，经常会遇到大部分主体对某个客体的权限完全一样的情况，如果规则只接受单个主体到单个客体的映射，会导致大量对同一个客体的重复定义。比如说，我们有三个类型对同一个客体的访问权限一致：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow trusted_app app_data_file:file { read write };
</span></span><span class=line><span class=cl>allow untrusted_app app_data_file:file { read write };
</span></span><span class=line><span class=cl>allow isolated_app app_data_file:file { read write };
</span></span></code></pre></div><p>为了解决这种繁琐的重复定义问题，SELinux 支持对访问控制规则进行分组，这项特性被称为属性（attributes）。</p><p>我们可以将域或类型分配到某一个属性，在定义访问控制规则时，可以利用属性进行定义，属性可以用在主体级别、对象级别或同时用于两者。</p><p>属性定义以及将属性用于规则的示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Associate the attribute appdomain with the type untrusted_app.
</span></span><span class=line><span class=cl>typeattribute untrusted_app appdomain;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Associate the attribute appdomain with the type isolated_app.
</span></span><span class=line><span class=cl>typeattribute isolated_app appdomain;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>allow appdomain app_data_file:file { read write };
</span></span></code></pre></div><p>至此，我们总结一下前面的内容。SELinux 绝大部分规则都是基于类型的规则。根据这些类型，SELinux 将授予或拒绝进程对文件的相应操作。多数情况下，在 SELinux 那冗长的上下文中我们只需要关注类型字段，而且由于完整的上下文真的太长了，下文也常常用 SELinux 类型来指代 SELinux 上下文这个概念。</p><blockquote><p>我们也可以在定义一个类型的语句中顺便定义这个类型所关联的属性。类型定义语法如下：</p><p><code>type 类型名 [alias { 别名1, 别名2 }] [, 属性1];</code></p><p>中括号不是语法内容，而是表示这部分内容可写可不写。alias 表示别名部分，可以为类型赋予其他多个别名。逗号后接的内容视为属性部分，同样也可以关联多个属性。比如，下述声明语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type httpd_t, file_type, domain;
</span></span></code></pre></div><p>既定义了一个 SELinux 类型 httpd_t，也将 httpd_t 这个 SELinux 类型关联到属性 file_type 和 domain，它等价于下述语句：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type httpd_t;
</span></span><span class=line><span class=cl>typeattribute httpd_t file_type, domain;
</span></span></code></pre></div></blockquote><h2 id=上下文继承>上下文继承<a hidden class=anchor aria-hidden=true href=#上下文继承>#</a></h2><p>默认情况下，若 SELinux 中没有其他指定的策略，则新的进程和文件的 SELinux 类型是从其父级继承而来的。比如说：</p><ul><li>以<code>foo_t</code>上下文运行的进程 fork 新的子进程时，此进程的上下文也为<code>foo_t</code></li><li>在上下文为<code>bar_t</code>的目录中创建的文件或目录也将获得<code>bar_t</code>上下文</li></ul><p>如同所有的进程的源头都是 init 进程一样，追溯 SELinux 的上下文继承体系，也有一个所谓的根上下文。进程和文件的根上下文都由相应的 SELinux 策略定义。一般来说，在 Linux 中文件的根上下文是<code>root_t</code>，进程的根上下文是<code>kernel_t</code>。</p><h2 id=域转换>域转换<a hidden class=anchor aria-hidden=true href=#域转换>#</a></h2><blockquote><p><a href=https://wiki.gentoo.org/wiki/SELinux/Tutorials/How_does_a_process_get_into_a_certain_context>进程如何进入特定的上下文</a></p></blockquote><p>既然进程有根上下文，那么 SELinux 势必要支持域转换，否则所有的进程只会拥有同一个上下文。进程可以通过三种方式进行域转换：</p><ul><li>通过 type_transition 语句自动转换</li><li>使用 libselinux 中的 setexeccon()</li><li>使用 libselinux 中的 setcon()</li></ul><p>第一种是为不支持 SELinux （不使用 libselinux ）且对 SELinux 一无所知的应用准备的；后两种则需要引入 libselinux 。<code>setexeccon()</code>函数可以指定下一次调用<code>exec()</code>后新进程的上下文，而<code>setcon()</code>最为特殊，它可以直接改变当前进程的上下文。</p><p>无论进程采用哪一种方式，SELinux 并不会自动许可域转换，所以我们在确定好哪些域要转换后，还必须编写相应的 allow 规则来放行这些转换。</p><blockquote><p>虽然从系统的角度来看，<code>exec()</code>并不会诞生新进程，但我们姑且把一个进程替换自身代码段的行为称之“创建”了新进程。</p></blockquote><h3 id=type_transition语句>type_transition语句<a hidden class=anchor aria-hidden=true href=#type_transition语句>#</a></h3><p>这是最常用的方式。我们知道，默认情况下，在新旧进程之间，域将原封不动地继承，但<code>type_transition</code>定义可以改变这种默认行为。一旦满足条件，SELinux 将根据<code>type_transition</code>语句决定新进程的域，域转换自动发生。</p><p><code>type_transition</code>定义的示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type_transition init_t initrc_exec_t : process initrc_t;
</span></span></code></pre></div><p>它的含义是：当 init_t 进程执行（通过<code>exec</code>）上下文为 initrc_exec_t 的文件时，生成的进程应在 initrc_t 上下文中运行。在满足后面我们会提到的条件后，SELinux 将自动执行域转换。</p><p>上面的示例展示了定义域转换所需的三个要素：原来的域，可执行文件的类型，新的域。</p><p>采用这种方式定义域转换不存在侵入性，因而非常适合那些不方便引入 libselinux 库的程序。即使应用程序引入了 libselinux，也经常依赖<code>type_transition</code>语句进行自动域转换。</p><h3 id=使用-libselinux-中的-setexeccon>使用 libselinux 中的 setexeccon()<a hidden class=anchor aria-hidden=true href=#使用-libselinux-中的-setexeccon>#</a></h3><p>支持 SELinux 的应用可以使用 libselinux 中的 setexeccon()，这个函数将设置用于下一个<code>exec()</code>调用的上下文。另外，应用必须具有 setexec 权限才能使用这个 API，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow crond_t self:process setexec;
</span></span></code></pre></div><p><code>self:process</code>是一种特殊的客体写法，但应该不难理解，它指明客体就是主体的这个进程。</p><h3 id=使用-libselinux-中的-setcon>使用 libselinux 中的 setcon()<a hidden class=anchor aria-hidden=true href=#使用-libselinux-中的-setcon>#</a></h3><p>应用还可以使用<code>setcon()</code>函数直接切换当前进程的上下文。和<code>setexeccon()</code>一样，进程执行<code>setcon()</code>也需要一个特殊的 SELinux 权限<code>setcurrent</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow crond_t self:process setcurrent;
</span></span></code></pre></div><p>使用这个 API 有一些额外的限制，比如，如果应用使用多线程，那么必须在创建任何子线程之前执行<code>setcon()</code>，这种情况下后续创建的所有子线程都将继承新的上下文。但是如果调用<code>setcon()</code>时同一进程中还有其他线程在运行，此调用将失败。</p><h3 id=域转换许可规则>域转换许可规则<a hidden class=anchor aria-hidden=true href=#域转换许可规则>#</a></h3><p>如果域转换最终需要执行<code>exec()</code>才生效（对应第一种和第二种域转换方式），那么，我们就需要添加三条 allow 规则来许可域转换。这些策略用来满足以下三个条件：</p><ol><li>原始域对文件具有执行权限</li><li>文件上下文本身被标识为目标域的入口点（entrypoint）</li><li>允许原始域转换到目标域</li></ol><p>我们以<code>initrc_t</code>进程通过执行<code>sshd_exec_t</code>文件来转换到<code>sshd_t</code>这个域为例。</p><p>首先，<code>exec()</code>调用需要指定某个可执行文件，这当然需要授予一个允许进程执行文件的权限。比如，允许<code>initrc_t</code>进程执行<code>sshd_exec_t</code>文件：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow initrc_t sshd_exec_t : file { read getattr execute open } ;
</span></span></code></pre></div><p>然后，SELinux 并不知道<code>sshd_exec_t</code>文件和<code>sshd_t</code>域之间到底有什么关系，因此我们需要添加一条规则来告诉 SELinux，执行<code>sshd_exec_t</code>文件时，可以将域转换到<code>sshd_t</code>。这种特性被我们称之为 entrypoint，定义的方式为，在通常的 allow 规则中，主体<code>sshd_t</code>对客体<code>sshd_exec_t</code>的操作集中添加 <code>entrypoint</code>，示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow sshd_t sshd_exec_t:file { ioctl read getattr lock execute execute_no_trans open entrypoint };
</span></span></code></pre></div><blockquote><p>由于“主体-操作-客体”的 SELinux 底层逻辑的限制，我们没办法以客体为主语，因此 entrypoint 的 allow 规则显得比较抽象，遇到 entrypoint 时，试着反过来理解 allow 规则，逻辑会更顺畅。</p></blockquote><p>最后，我们还需要告诉 SELinux，允许从<code>initrc_t</code>域转换到<code>sshd_t</code>域。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow initrc_t sshd_t:process transition;
</span></span></code></pre></div><p>为什么我们最后需要定义一个 allow 规则来允许一个域向另一个域转换？这是因为一个文件可以成为多个域的 entrypoint，比如说，<code>sshd_exec_t</code>同时还是<code>xm_ssh_t</code>域和<code>ssh_t</code>域的 entrypoint。因此，SELinux 不允许一个域获得一个文件的执行权限就可以根据 entrypoint 定义转换到其他所有域， SELinux 要求明确指出，从哪个域到哪个域的转换才是被允许的。</p><hr><p>如果应用使用<code>setcon()</code>直接切换本进程的上下文，那么，我们需要添加对目标上下文的<code>dyntransition</code>操作的 allow 规则，表明一个上下文可以“动态”切换到目标上下文。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow adbd su:process dyntransition;
</span></span></code></pre></div><p>这是 Android 中的 SELinux 规则的一个例子，它表明在 adbd 域中的进程可以动态切换到 su 域中。</p><h2 id=客体的类型转换>客体的类型转换<a hidden class=anchor aria-hidden=true href=#客体的类型转换>#</a></h2><p>和进程间的域转换类似，我们也可以为客体定义相应的类型转换语句，让 SELinux 在满足相应条件后自动执行类型转换。例如，现在有一个域为<code>ext_gateway_t</code>的进程，希望在类型为<code>in_queue_t</code>的文件夹内保存文件时，该文件的类型不继承父目录的类型，而是使用另一个类型<code>in_file_t</code>。示例的定义语句如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type_transition | source_domain |  target_type :    object
</span></span><span class=line><span class=cl>----------------▼---------------▼--------------▼-----------------
</span></span><span class=line><span class=cl>type_transition   ext_gateway_t    in_queue_t  : file in_file_t;
</span></span></code></pre></div><p>这个 type_transition 语句的含义是，当在<code>ext_gateway_t</code>域（source_domain） 中运行的进程想要在类型为<code>in_queue_t</code>的目录中创建<code>file</code>对象时，如果策略允许，则应将该文件重新标记为<code>in_file_t</code></p><p>为了能够创建文件，我们还需要在 SELinux 中添加相应的 allow 规则。</p><ul><li><p>源域需要有权限将<code>file</code>添加到<code>in_queue_t</code>目录中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow ext_gateway_t in_queue_t:dir { write search add_name };
</span></span></code></pre></div></li><li><p>源域需要有创建<code>in_file_t</code>文件的权限</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>allow ext_gateway_t in_file_t:file { write create getattr };
</span></span></code></pre></div></li></ul><h2 id=selinux上下文与其他安全模型>SELinux上下文与其他安全模型<a hidden class=anchor aria-hidden=true href=#selinux上下文与其他安全模型>#</a></h2><p>我们已经围绕着 TE 模型及其规则介绍了许多内容，相信你已经体会到它的强大之处。靠着 TE 模型，SELinux 似乎已经可以工作得很好，但人类的需求总是复杂多变。不同于 TE 模型的设计思路，人类经常以用户、角色、项目等比较抽象的概念来管理权限。SELinux 为这些希望使用不同安全模型的需求提供了直接的支持，实际上，安全上下文中我们尚未介绍到的那些字段全都是用来支持其他安全模型的。</p><p>SELinux 角色与 SELinux 用户直接支持了 RBAC （Role-Based Access Control，基于角色的访问控制）模型；SELinux 敏感度级别则支持了 MCS（Multi-Level Security）和 MLS（Multi-Category Security）模型。</p><p>这些名词你可能很熟悉也可能很陌生，我们稍后会解释这些名词的含义。但重要的是要理解，这些安全模型都是建立在 TE 模型之上的额外的“高级”模型，只有通过 SELinux 类型的检查后，SELinux 上下文的其他部分才会继续发挥作用。SELinux 提供这些功能只是为了便于人类进行管理，但不使用它们，SELinux 也能正常运行。</p><h2 id=角色与rbac模型>角色与RBAC模型<a hidden class=anchor aria-hidden=true href=#角色与rbac模型>#</a></h2><p>首先，需要说明的一点是，SELinux 角色只针对主体，对客体（文件）来说没有意义，因此，如果你使用<code>ls -Z</code>来查看文件的角色，你会发现它们清一色都是<code>object_r</code>。这个字符串只是因 SELinux 上下文不能缺少角色字段而存在的一个占位符，将进程更改为以 object_r 角色运行或尝试为文件分配不同的角色始终会被内核拒绝。</p><p>那么，SELinux 中的角色与主体的访问控制之间有什么联系呢？为了回答这个问题，我们首先捋清楚 Linux 用户、SELinux 用户、SELinux 角色和域（SELinux 类型）之间的关系，如下图所示。</p><p><img loading=lazy src=https://wiki.gentoo.org/images/a/a0/SELinux_users.png></p><p>SELinux 用户与 Linux 用户不同，它是一个独立的概念。在 SELinux 中，每个 Linux 用户都必须映射到且只能映射到一个 SELinux 用户，但支持多个 Linux 用户映射到同一个 SELinux 用户上；SELinux 用户与 SELinux 角色则是一种多对多的关系，每个 SELinux 用户都可以持有多个角色；而对于每一个 SELinux 角色来说，它们可以关联到不同的域。</p><p>这种关联是在规定 SELinux 角色可以进入哪些域（上下文）。当然，用户控制的进程需要先通过域转换这一关， SELinux 角色的限制则在于，即使被允许转换到目标域，如果该域未附加到相应角色，转换也会失败。</p><p>我们举一个例子说明这一点：</p><p>假设一名开发人员试图从命令行启动 mysql 守护进程。我们知道，shell 进程被允许执行<code>mysqld_exec_t</code>文件并进行域转换，新的守护进程的上下文应该是<code>mysqld_t</code>，但不巧的是，这名人员的角色是<code>user_r</code>而不是数据管理员<code>dbadm_r</code>，<code>mysqld_t</code>这个域只与数据管理员关联，而没有关联到<code>user_r</code>这个角色上，因此本次操作将被 SELinux 阻止。</p><p>总的来说，角色进一步限制了用户能够与哪些进程打交道。</p><h3 id=rbac模型>RBAC模型<a hidden class=anchor aria-hidden=true href=#rbac模型>#</a></h3><p>SELinux 角色可以用于实现 RBAC （Role-Based Access Control，基于角色的访问控制），RBAC 是一种抽象的访问控制模型， 核心理念是：</p><ul><li>权限始终通过角色授予，不直接分配给用户</li><li>必须明确授予用户相应角色，没有角色，就没有权限</li></ul><h2 id=mls与mcs>MLS与MCS<a hidden class=anchor aria-hidden=true href=#mls与mcs>#</a></h2><p>我们介绍 SELinux 上下文中的最后那一部分：敏感度级别。其实在之前的示例中，我们没有完整展现这一部分的内容，实际上敏感度级别分为两个维度的内容，分别是秘密等级和类别集。比如说下面的上下文：</p><p><code>user_u:user_r:user_t:s0:c0,c1</code></p><p><code>s0</code>表示秘密等级，<code>c0,c1</code>表示类别集是0和1。</p><p>秘密等级可以看作对现实中的秘密等级的抽象实现。如果你了解《中华人民共和国保守国家秘密法》，应该知道所谓的“国家秘密”分为三种：绝密、机密和秘密。体现到 SELinux 上，我们可以规定，s3 表示绝密，s2 表示机密，s1 表示秘密，s0 表示公开。这样一来，即使 SELinux 类型允许进程访问高等级秘密文件，但由于秘密等级不匹配，进程依旧会读取失败。比如说，对于 s2 的进程来说，它可以读取 s2 或更低级别的文件，但无法读取更高级别比如 s3 文件。秘密等级实现了所谓的多级安全性（Multi-Level Security，MLS）。</p><p>结合上面的秘密等级，类别集可以理解为，我们有两个秘密等级相同的项目，比如有两个 s3 绝密项目，虽然它们秘密等级相同，我们也不希望这两个项目之间的人员（进程）互相查看对方的资料（文件），因此，我们使用类别来区分这两个项目。比如说，项目 X 被划分到<code>c0</code>，项目 Y 被划分到<code>c1</code>，那么，持有<code>s3:c0</code>的进程可以访问项目 X 的文件，但无法访问项目 Y 的文件了。SELinux 使用类别集，实现了所谓的多类别安全性（Multi-Category Security，MCS）。</p><p>最后，我们说明一下这部分上下文的一些特殊形式。对于秘密等级，可以使用<code>-</code>符号来表示范围，比如<code>s0-s2</code>就表示从 s0 到 s2 的等级。对于类别集，可以使用<code>.</code>符号来表示范围，比如<code>c0.c15</code>表示从类别集 c0 到 c15。</p><h2 id=拒绝日志>拒绝日志<a hidden class=anchor aria-hidden=true href=#拒绝日志>#</a></h2><p>本节简单介绍一下 SELinux 拒绝日志里面包含了什么内容，至于如何根据拒绝日志添加 SELinux 策略，这是一个比较复杂的问题，本节不会讨论。</p><p>在查看拒绝信息之前，我们需要注意以下几点：</p><ol><li>在日志中发现的拒绝并非都是大问题。有些拒绝只是表面上发生了，但不会影响应用程序的行为。这通常是由于应用程序开发不当（例如未正确关闭文件描述符）或由于高级库函数（应用程序仅使用了一小部分功能）造成的。</li><li>拒绝一出现就会被记录下来。这意味着在日志中我们将看到大量的拒绝，尽管许多拒绝彼此相关（一个拒绝导致另一个拒绝），但大部分拒绝与正在调查的问题无关。</li><li>如果连续出现太多拒绝，Linux 内核可能会抑制这些拒绝。因此可能看不到 SELinux 报告的所有内容。</li><li><code>dontaudit</code>会抑制拒绝日志的输出，因此，不要太依赖日志，必要的时候请 review 相应的 SELinux 策略。</li></ol><p>拒绝日志的示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>avc: denied { open } for pid=1003 comm=”mediaserver” path=&#34;/dev/kgsl-3d0”
</span></span><span class=line><span class=cl>dev=&#34;tmpfs&#34; scontext=u:r:mediaserver:s0 tcontext=u:object_r:device:s0
</span></span><span class=line><span class=cl>tclass=chr_file permissive=1
</span></span></code></pre></div><p>下表给出了每一部分日志的解释</p><table><thead><tr><th>日志</th><th>描述</th></tr></thead><tbody><tr><td>avc:</td><td>告知用户这是哪种类型的日志条目。在本例中，这是 AVC 日志条目。</td></tr><tr><td>denied</td><td>SELinux 最终的反应，可以是 denied 或 granted。注意，如果 SELinux 处于宽容模式，尽管实际没有拒绝，在日志中依然会被记录 denied</td></tr><tr><td>{ open }</td><td>试图执行的操作，有时会包含一组操作，如{ read write }</td></tr><tr><td>pid=1003</td><td>进程 pid</td></tr><tr><td>comm=”mediaserver”</td><td>进程命令（不带参数，且限制为 15 个字符），帮助用户在进程已经死亡的情况下识别该进程是什么</td></tr><tr><td>path=</td><td>目标的绝对路径。注意，此字段很大程度上取决于目标类别，因此可能是path=、name=、capacity=、src= 等等</td></tr><tr><td>dev=&ldquo;tmpfs&rdquo;</td><td>目标所在的设备</td></tr><tr><td>scontext=</td><td>进程的上下文（域）</td></tr><tr><td>tcontext=</td><td>目标资源（本例中为文件）的上下文</td></tr><tr><td>tclass=</td><td>目标的类别</td></tr><tr><td>permissive=1</td><td>表示是否允许此次操作，为1表示允许</td></tr></tbody></table><h2 id=本文的selinux策略语法>本文的SELinux策略语法<a hidden class=anchor aria-hidden=true href=#本文的selinux策略语法>#</a></h2><p>SELinux 有两套<a href=http://selinuxproject.org/page/PolicyLanguage#CIL_Policy_Language>策略语言</a>，分别是 CIL 策略语言和内核策略语言。本文所展示的 SELinux 策略代码均基于内核策略语言。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://usagisang.github.io/posts/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/><span class=title>« 上一页</span><br><span>数据流中的中位数</span>
</a><a class=next href=https://usagisang.github.io/posts/gcd%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/><span class=title>下一页 »</span><br><span>gcd的递归与非递归实现</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on x" href="https://x.com/intent/tweet/?text=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;url=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f&amp;title=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;summary=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;source=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f&title=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on whatsapp" href="https://api.whatsapp.com/send?text=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%20-%20https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on telegram" href="https://telegram.me/share/url?text=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&amp;url=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share SELinux快速入门 on ycombinator" href="https://news.ycombinator.com/submitlink?t=SELinux%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&u=https%3a%2f%2fusagisang.github.io%2fposts%2fselinux%25E5%25BF%25AB%25E9%2580%259F%25E5%2585%25A5%25E9%2597%25A8%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=comments-container class=comments-container><br><hr style=border-color:#dfdfdf3d><section class="article discussion"><script>let currentTheme=window.localStorage.getItem("pref-theme");function loadComment(){let t=currentTheme=="dark"?"photon-dark":"github-light",e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","usagisang/usagisang.github.io"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector("section.article.discussion").innerHTML="",document.querySelector("section.article.discussion").appendChild(e)}loadComment(),document.getElementById("theme-toggle").onclick=async()=>{await new Promise(e=>setTimeout(e,200));let e=window.localStorage.getItem("pref-theme");e!=currentTheme&&(currentTheme=e,loadComment())}</script></section></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://usagisang.github.io/>Milky Way</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>